!!strict

--TODO: function type overload
--TODO: become a module

--------------------------------------------------------------------------------
-- math module imports

!!cinclude '<math.h>'
!!cinclude '<stdlib.h>'

local math = @record{}

global math.pi: compconst = 3.141592653589793
global math.maxinteger: compconst = 9223372036854775807
global math.mininteger: compconst = -9223372036854775807-1
global math.huge: number !cimport 'HUGE_VAL'

function math.abs(x: number): number !cimport 'fabs' end
function math.ceil(x: number): number !cimport 'ceil' end
function math.floor(x: number): number !cimport 'floor' end
function math.max(x: number, y: number): number !cimport 'fmax' end
function math.min(x: number, y: number): number !cimport 'fmin' end
function math.acos(x: number): number !cimport 'acos' end
function math.asin(x: number): number !cimport 'asin' end
function math.atan(x: number): number !cimport 'atan' end
function math.cos(x: number): number !cimport 'cos' end
function math.sin(x: number): number !cimport 'sin' end
function math.tan(x: number): number !cimport 'tan' end
function math.sqrt(x: number): number !cimport 'sqrt' end
function math.exp(x: number): number !cimport 'exp' end
function math.log(x: number): number !cimport 'log' end
function math.fmod(x: number, y: number): number !cimport 'fmod' end

-- used internally
local RAND_MAX: int32 !cimport
local function clog2(x: number): number !cimport 'log2' end
local function clog10(x: number): number !cimport 'log10' end
local function cmodf(x: number, y: number*): number !cimport 'modf' end
local function crand(): int32 !cimport 'rand' end
local function csrand(x: uint32) !cimport 'srand' end

function math.atan2(x: number, y: number): number !cimport 'atan2' end

local function math_logbase(x: number, base: number): number
  if base == 2 then
    return clog2(x)
  elseif base == 10 then
    return clog10(x)
  end
  return math.log(x) / math.log(base)
end

function math.deg(x: number)
  return x * (180.0 / math.pi)
end

function math.rad(x: number)
  return x * (math.pi / 180.0)
end

function math.modf(x: number)
  local i: number
  local f = cmodf(x, &i)
  return i, f
end

function math.ult(m: integer, n: integer): boolean
  return @uinteger(m) < @uinteger(n)
end

function math.tointeger(x: number)
  return @integer(x)
end

function math.type(x: number)
  return 'float'
end

-- Pseudo Random Number Generator based on xoshiro256**

local xoshiro256 = @record{state: uint64[4]}

local compconst FLOAT64_MANT_DIGS = 53

local function rotl(x: uint64, n: int32) !inline
  return (x << n) | (x >> (64 - n))
end

function xoshiro256:nextrand(): uint64
  local state: uint64[4] = {
    self.state[0],
    self.state[1],
    self.state[2] ~ self.state[0],
    self.state[3] ~ self.state[1]
  }
  local res = rotl(state[1] * 5, 7) * 9
  self.state[0] = state[0] ~ state[3]
  self.state[1] = state[1] ~ state[2]
  self.state[2] = state[2] ~ (state[1] << 17)
  self.state[3] = rotl(state[3], 45)
  return res
end

function xoshiro256:random(): number
  local rv = self:nextrand()
  local v = rv >> (64_i32 - FLOAT64_MANT_DIGS)
  return v / (1_uint64 << FLOAT64_MANT_DIGS)
end

function xoshiro256:seed(a: uint64, b: uint64)
  self.state[0] = a
  self.state[1] = 0xff
  self.state[2] = b
  self.state[3] = 0
  for i=0,<16 do
    self:nextrand()
  end
end

-- pre initialized default random generator
local default_random = xoshiro256{state={
  0x65CE039BAEBE74B4, 0x4911ADA153B51EEF, 0xFB71FBB497C00950, 0xF83CCF6AC1B74755
}}

function math.randomseed(x: integer)
  default_random:seed(@uint64(x), 0)
end

function math.random(): number
  return default_random:random()
end

--TODO:randommax
--TODO:randomrange

--[[
!!cinclude '<time.h>'
local function ctime(tloc: pointer): clong !cimport 'time' end
function math.randomseed()
  default_random:seed(@uint64(ctime(nilptr)), 0)
end
]]

--------------------------------------------------------------------------------
-- tests

local function assert_equal(x: number, y: number)
  assert(math.abs(x - y) < 1e-12)
end

local e: compconst = 2.718281828459045
assert_equal(math.abs(-1.0), 1)
assert_equal(math.abs(1.0), 1)
assert_equal(math.ceil(0.1), 1)
assert_equal(math.ceil(1.0), 1)
assert_equal(math.floor(0.9), 0)
assert_equal(math.floor(0.0), 0)

assert_equal(math.min(1.0, -1.0), -1)
assert_equal(math.min(-1.0, 1.0), -1)
assert_equal(math.max(1.0, -1.0), 1)
assert_equal(math.max(-1.0, 1.0), 1)
assert(math.min(math.huge, -math.huge) == -math.huge)
assert(math.max(math.huge, -math.huge) == math.huge)

assert_equal(math.acos(-1.0), math.pi)
assert_equal(math.acos(1.0), 0)
assert_equal(math.asin(0.0), 0)
assert_equal(math.asin(1.0), math.pi/2)
assert_equal(math.atan(0.0), 0)
assert_equal(math.atan(1.0), math.pi/4)
assert_equal(math.atan2(0.0, 1.0), 0)
assert_equal(math.atan2(0.0, -1.0), math.pi)

assert_equal(math.cos(math.pi), -1)
assert_equal(math.cos(0.0), 1)
assert_equal(math.sin(math.pi/2), 1)
assert_equal(math.sin(0.0), 0)
assert_equal(math.tan(math.pi/4), 1)
assert_equal(math.tan(0.0), 0)

assert_equal(math.deg(math.pi / 2), 90)
assert_equal(math.deg(0), 0)
assert_equal(math.rad(90), math.pi / 2)
assert_equal(math.rad(0), 0)

assert_equal(math.sqrt(4.0), 2)
assert_equal(math.sqrt(9.0), 3)
assert_equal(math.exp(0), 1)
assert_equal(math.exp(1), e)
assert_equal(math.log(1), 0)
assert_equal(math.log(e), 1)
assert_equal(math_logbase(1, 2), 0)
assert_equal(math_logbase(2, 2), 1)
assert_equal(math_logbase(1, 10), 0)
assert_equal(math_logbase(10, 10), 1)

assert_equal(math.fmod(5, 2), 1)
assert_equal(math.fmod(2.3, 5.7), 2.3)

do
  local i: number, f: number
  i, f = math.modf( 5.0)  assert_equal(i, 5)  assert_equal(f, 0.0)
  i, f = math.modf( 5.3)  assert_equal(i, 5)  assert_equal(f, 0.3)
  i, f = math.modf(-5.3)  assert_equal(i,-5)  assert_equal(f,-0.3)
end

assert(not (math.maxinteger < math.mininteger))
assert(math.ult(math.maxinteger, math.mininteger))
assert(math.tointeger(1.0) == 1_integer)
assert(math.type(1.0) == 'float')

math.randomseed(0)

do
  for i=1,10 do
    local x: number = math.random()
    assert(x >= 0 and x <= 1)
  end
end
