local pegger = require 'nelua.utils.pegger'
local stringer = require 'nelua.utils.stringer'
local fs = require 'nelua.utils.fs'
local except = require 'nelua.utils.except'
local executor = require 'nelua.utils.executor'
local tabler = require 'nelua.utils.tabler'
local sstream = require 'nelua.utils.sstream'
local console = require 'nelua.utils.console'
local config = require 'nelua.configer'.get()
local cdefs = require 'nelua.cdefs'

local compiler = {}

local function get_compile_args(infile, outfile, compileopts)
  local compiler_flags = cdefs.compilers_flags[config.cc] or cdefs.compiler_base_flags
  local cflags = sstream(compiler_flags.cflags_base)
  cflags:add(' ')
  cflags:addlist(compiler_flags.cflags_warn, ' ')
  cflags:add(' ', config.release and compiler_flags.cflags_release or compiler_flags.cflags_debug)
  if config.cflags then
    cflags:add(' ', config.cflags)
  end
  if #compileopts.cflags > 0 then
    cflags:add(' ')
    cflags:addlist(compileopts.cflags, ' ')
  end
  if #compileopts.ldflags > 0 then
    cflags:add(' -Wl,')
    cflags:addlist(compileopts.ldflags, ',')
  end
  if #compileopts.linklibs > 0 then
    cflags:add(' -l')
    cflags:addlist(compileopts.linklibs, ' -l')
  end
  local env = { infile = infile, outfile = outfile, cflags = cflags:tostring(), cc = config.cc }
  return pegger.substitute('$(cc) $(cflags) -o "$(outfile)" "$(infile)"', env)
end

local last_ccinfos = {}
local function get_cc_info()
  local cccmd = string.format('%s -v -x c -E /dev/null', config.cc)
  local last_ccinfo = last_ccinfos[config.cc]
  if last_ccinfo then return last_ccinfo end
  local ok, ret, stdout, ccinfo = executor.execex(cccmd)
  except.assertraisef(ok and ret == 0, "failed to retrive compiler information: %s", ccinfo or '')
  last_ccinfos[config.cc] = ccinfo
  return ccinfo
end

function compiler.compile_code(ccode, outfile, compileopts)
  local cfile = outfile .. '.c'
  local ccinfo = get_cc_info()
  local ccmd = get_compile_args(cfile, outfile, compileopts)

  -- file heading
  local hash = stringer.hash(string.format("%s%s%s", ccode, ccinfo, ccmd))
  local heading = string.format(
[[/* This file was auto generated by Nelua. */
/* Compile command: %s */
/* Compile hash: %s */

]], ccmd, hash)
  local sourcecode = heading .. ccode

  -- check if write is actually needed
  local current_sourcecode = fs.tryreadfile(cfile)
  if not config.no_cache and current_sourcecode and current_sourcecode == sourcecode then
    if not config.quiet then console.info("using cached generated " .. cfile) end
    return cfile
  end

  fs.ensurefilepath(cfile)
  fs.writefile(cfile, sourcecode)
  if not config.quiet then console.info("generated " .. cfile) end

  return cfile
end

function compiler.compile_binary(cfile, outfile, compileopts)
  -- if the file with that hash already exists skip recompiling it
  if not config.no_cache then
    local cfile_mtime = fs.getfiletime(cfile)
    local outfile_mtime = fs.getfiletime(outfile)
    if cfile_mtime and outfile_mtime and cfile_mtime <= outfile_mtime then
      if not config.quiet then
        console.info("using cached binary " .. outfile)
      end
      return outfile
    end
  end

  fs.ensurefilepath(outfile)

  -- generate compile command
  local cccmd = get_compile_args(cfile, outfile, compileopts)
  if not config.quiet then console.info(cccmd) end

  -- compile the file
  local success, status, stdout, stderr = executor.execex(cccmd)
  except.assertraisef(success and status == 0,
    "C compilation for '%s' failed:\n%s", outfile, stderr or '')

  if stderr then
    io.stderr:write(stderr)
  end

  return outfile
end

function compiler.get_run_command(binaryfile, runargs)
  return fs.abspath(binaryfile), tabler.copy(runargs)
end

return compiler
