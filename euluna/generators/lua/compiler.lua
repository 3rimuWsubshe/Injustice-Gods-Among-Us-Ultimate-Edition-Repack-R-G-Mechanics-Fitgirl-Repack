local fs = require 'euluna.utils.fs'
local pltemplate = require 'pl.template'
local stringer = require 'euluna.utils.stringer'
local config = require 'euluna.configer'.get()
local metamagic = require 'euluna.utils.metamagic'
local lua_compiler = {}

function lua_compiler.compile_code(luacode, outfile)
  local luafile = outfile .. '.lua'

  -- file heading
  local hash = stringer.sha1(luacode)
  local heading = string.format(
[[-- This file was auto generated by Euluna.
-- Compile Hash: %s

]], hash)
  local sourcecode = heading .. luacode

  -- check if write is actually needed
  local current_sourcecode = fs.tryreadfile(luafile)
  if not config.no_cache and current_sourcecode and current_sourcecode == sourcecode then
    if not config.quiet then print("using cached generated " .. luafile) end
    return luafile
  end

  fs.ensurefilepath(luafile)
  fs.writefile(luafile, sourcecode)
  if not config.quiet then print("generated " .. luafile) end

  return luafile
end

function lua_compiler.compile_binary(luafile)
  return luafile
end

function lua_compiler.get_run_command(binaryfile)
  -- generate compile command
  local env = {binaryfile = binaryfile}
  metamagic.setmetaindex(env, config)
  return pltemplate.substitute("$(lua) $(lua_options) $(binaryfile)", env)
end

return lua_compiler
