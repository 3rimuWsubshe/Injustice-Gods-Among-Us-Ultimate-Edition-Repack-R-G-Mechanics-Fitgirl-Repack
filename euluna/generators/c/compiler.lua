local pldir = require 'pl.dir'
local plfile = require 'pl.file'
local plpath = require 'pl.path'
local plutil = require 'pl.utils'
local pltemplate = require 'pl.template'
local config = require 'euluna.configer'.get()
local metamagic = require 'euluna.utils.metamagic'
local sha1 = require 'sha1'.sha1
local compiler = {}

local function get_compile_command(infile, outfile)
  local env = {infile = infile, outfile = outfile}
  env.cc = os.getenv('CC')
  env.cflags = os.getenv('CFLAGS')
  env.ldflags = os.getenv('LDFLAGS')
  metamagic.setmetaindex(env, config)
  return pltemplate.substitute("$(cc) $(cflags) -o $(outfile) $(ldflags) $(infile)", env)
end

local last_ccinfos = {}
local function get_cc_info()
  local ccinfocmd = string.format("%s -v -x c -E /dev/null", config.cc)
  local last_ccinfo = last_ccinfos[ccinfocmd]
  if last_ccinfo then return last_ccinfo end
  local ok, ret, stdout, ccinfo = plutil.executeex(ccinfocmd)
  if not ok or ret ~= 0 then
    return nil, string.format("failed to retrive compiler information: %s", tostring(ccinfo))
  end
  last_ccinfos[ccinfocmd] = ccinfo
  return ccinfo
end

local function hash_compilation(ccode)
  local dummycmd = get_compile_command('dummy.c', 'dummy')
  local ccinfo, err = get_cc_info()
  if not ccinfo then return nil, err end
  return sha1(string.format("%s%s%s", ccode, ccinfo, dummycmd))
end

function compiler.compile_code(ccode, outfile)
  local cfile = outfile .. '.c'

  -- create output directory if needed
  local outdir = plpath.dirname(cfile)
  local ok, err = pldir.makepath(outdir)
  if not ok then return nil, string.format('failed to create path for compiling "%s": %s', cfile, err) end

  -- file heading
  local hash
  hash, err = hash_compilation(ccode)
  if not hash then return nil, err end
  local heading = string.format(
[[/* This file was auto generated by Euluna. */
/* Compile Hash: %s */

]], hash)
  local sourcecode = heading .. ccode

  -- check if write is actually needed
  local current_sourcecode = plfile.read(cfile)
  if not config.no_cache and current_sourcecode and current_sourcecode == sourcecode then
    if not config.quiet then print("using cached generated " .. cfile) end
    return cfile
  end

  -- save sources to a file
  ok, err = plfile.write(cfile, sourcecode)
  if not ok then return nil, string.format('failed to create file for compiling "%s": %s', cfile, err) end
  if not config.quiet then print("generated " .. cfile) end

  return cfile
end

function compiler.compile_binary(cfile, outfile)
  -- if the file with that hash already exists skip recompiling it
  if not config.no_cache then
    local cfile_mtime = plfile.modified_time(cfile)
    local outfile_mtime = plfile.modified_time(outfile)
    if cfile_mtime and outfile_mtime and cfile_mtime <= outfile_mtime then
      if not config.quiet then
        print("using cached binary " .. outfile)
      end
      return outfile
    end
  end

  -- create output directory if needed
  local outdir = plpath.dirname(outfile)
  local ok, err = pldir.makepath(outdir)
  if not ok then return nil, string.format('failed to create path for compiling "%s": %s', outfile, err) end

  -- generate compile command
  local cmd = get_compile_command(cfile, outfile)
  if not config.quiet then print(cmd) end

  -- compile the file
  local execok, status, stdout, stderr = plutil.executeex(cmd)
  if not execok or status ~= 0 then
    return nil, string.format("C compilation for '%s' failed:\n%s", outfile, tostring(stderr))
  end

  return outfile
end

function compiler.get_run_command(binaryfile)
  return './' .. binaryfile
end

return compiler
