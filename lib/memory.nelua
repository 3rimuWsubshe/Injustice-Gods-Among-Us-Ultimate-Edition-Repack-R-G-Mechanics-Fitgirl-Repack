##[[
strict = true
unitname = 'nelua'

--------------------------------------------------------------------------------
-- compile time checks utilities
local function check_span_subtype(v)
  staticassert(v.type:is_span(),
    "in argument '%s': expected 'span(T)' but got type '%s'",
    v.name, v.type)
  return v.type.subtype
end

local function check_type_match(a, b)
  staticassert(a.type == b.type,
    "argument '%s' type '%s' differs from argument '%s' type '%s",
    a.name, b.name, a.type, b.type)
end

local function check_span_subtype_match(s, x)
  local stype = check_span_subtype(s)
  staticassert(stype == x.type,
    "in argument '%s': type '%s' differs from argument '%s' type '%s",
    s.name, x.name, stype, x.type)
end
]]

local function memcpy(dest: pointer, src: pointer, n: csize): pointer <cimport'memcpy',cinclude'<string.h>',nodecl> end
local function memmove(dest: pointer, src: pointer, n: csize): pointer <cimport'memmove',cinclude'<string.h>',nodecl> end
local function memset(s: pointer, c: cint, n: csize): pointer <cimport'memset',cinclude'<string.h>',nodecl> end
local function memcmp(s1: pointer, s2: pointer, n: csize): cint <cimport'memcmp',cinclude'<string.h>',nodecl> end
local function memchr(s: pointer, c: cint, n: csize): pointer <cimport'memchr',cinclude'<string.h>',nodecl> end

local function malloc(size: csize): pointer <cimport'malloc',cinclude'<stdlib.h>',nodecl> end
local function calloc(nmemb: csize, size: csize): pointer <cimport'calloc',cinclude'<stdlib.h>',nodecl> end
local function realloc(ptr: pointer, size: csize): pointer <cimport'realloc',cinclude'<stdlib.h>',nodecl> end
local function free(ptr: pointer): void <cimport'free',cinclude'<stdlib.h>',nodecl> end

global memory = @record{}

--------------------------------------------------------------------------------
-- pointer functions

function memory.copy(dest: pointer, src: pointer, size: usize)
  check(dest and src, 'memory.copy: invalid pointer')
  memcpy(dest, src, size)
end

function memory.move(dest: pointer, src: pointer, size: usize)
  check(dest and src, 'memory.move: invalid pointer')
  memmove(dest, src, size)
end

function memory.set(dest: pointer, x: byte, size: usize)
  check(dest, 'memory.set: invalid pointer')
  memset(dest, x, size)
end

function memory.zero(dest: pointer, size: usize)
  check(dest, 'memory.set: invalid pointer')
  memset(dest, 0, size)
end

function memory.compare(a: pointer, b: pointer, size: usize): int32
  check(a and b, 'memory.move: invalid pointer')
  return memcmp(a, b, size)
end

function memory.equals(a: pointer, b: pointer, size: usize): boolean
  check(a and b, 'memory.equals: invalid pointer')
  return memcmp(a, b, size) == 0
end

function memory.scan(p: pointer, x: byte, size: usize): pointer
  check(p, 'memory.scan: invalid pointer')
  return memchr(p, x, size)
end

function memory.contains(p: pointer, x: byte, size: usize): boolean
  check(p, 'memory.contains: invalid pointer')
  return memchr(p, x, size) ~= nilptr
end

--------------------------------------------------------------------------------
-- span functions

function memory.spancopy(dest: auto, src: auto)
  local T: type = #[check_span_subtype(dest)]#
  ## check_type_match(dest, src)
  check(dest.size == src.size, 'memory.spancopy: span sizes must be equal')
  if likely(src.size > 0_u) then
    memcpy(dest.data, src.data, src.size * #T)
  end
end

function memory.spanmove(dest: auto, src: auto)
  local T: type = #[check_span_subtype(dest)]#
  ## check_type_match(dest, src)
  check(dest.size == src.size, 'memory.spanmove: span sizes must be equal')
  if likely(src.size > 0_u) then
    memmove(dest.data, src.data, src.size * #T)
  end
end

function memory.spanset(dest: auto, x: auto)
  ## check_span_subtype_match(dest, x)
  local T: type = #[x.type]#
  for i:usize=0,<dest.size do
    memcpy(&dest[i], &x, #T)
  end
end

function memory.spanzero(dest: auto)
  ## check_span_subtype(dest)
  local T: type = #[dest.type.subtype]#
  memset(dest.data, 0, dest.size * #T)
end

function memory.spancompare(a: auto, b: auto): int32
  ## check_span_subtype(a) check_type_match(a, b)
  local size: usize <noinit>
  if a.size < b.size then
    size = a.size
  else
    size = b.size
  end
  local ret: int32
  if likely(size > 0_u) then
    ret = memcmp(a.data, b.data, size)
  end
  if ret == 0 and a.size ~= b.size then
    if a.size < b.size then
      ret = -1
    else
      ret = 1
    end
  end
  return ret
end

function memory.spanequals(a: auto, b: auto): boolean
  ## check_span_subtype(a) check_type_match(a, b)
  local ret: boolean = a.size == b.size
  if ret and likely(a.size > 0_u) then
    ret = memcmp(a.data, b.data, a.size) == 0
  end
  return ret
end

function memory.spanscan(s: auto, x: auto): integer
  ## check_span_subtype_match(s, x)
  local T: type = #[x.type]#
  for i:usize=0,<s.size do
    if memcmp(&s[i], &x, #T) == 0 then
      return (@integer)(i)
    end
  end
  return -1
end

function memory.spancontains(s: auto, x: auto): boolean
  ## check_span_subtype_match(s, x)
  local T: type = #[x.type]#
  for i:usize=0,<s.size do
    if memcmp(&s[i], &x, #T) == 0 then
      return true
    end
  end
  return false
end
