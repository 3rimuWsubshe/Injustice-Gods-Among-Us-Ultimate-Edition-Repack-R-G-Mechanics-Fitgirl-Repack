--TODO: lazy functions to make it generic

## strict = true
## unitname = 'nelua'

## local myarraytable = hygienize(memoize(function(T, allocator)
  ## staticassert(traits.is_type(T), "invalid type '%s'", T)
  ## if allocator then
  local allocator: type = #[allocator]#
  ## else
  require 'allocators.gc_allocator'
  local allocator: type = @gc_allocator
  ## end

  local T = @#[T]#
  local ArrayTableImplT <codename #['nelua_ArrayTableImpl_'..T.name]#> = @record {
    size: usize,
    data: span(T)
  }
  local ArrayTableT <codename #['nelua_ArrayTable_'..T.name]#> = @record{
    impl: ArrayTableImplT*
  }
  ##[[
  ArrayTableT.value.choose_braces_type = function(node)
    return types.ArrayType(nil, T, #node[1])
  end
  ]]

  local convertible_concept: type = #[concept(function(x)
    if x.type:is_array_of(T) then
      return true
    end
  end)]#

  function ArrayTableT:init() <inline>
    if unlikely(not self.impl) then
      self.impl = (@ArrayTableImplT*)(allocator.alloc0(#ArrayTableImplT))
    end
  end

  function ArrayTableT.create(): ArrayTableT <inline>
    local self: ArrayTableT
    self:init()
    return self
  end

  function ArrayTableT:reset()
    if likely(self.impl) then
      allocator.spandealloc(self.impl.data)
      allocator.dealloc(self.impl)
      self.impl = nilptr
    end
  end

  function ArrayTableT:_grow()
    local cap: usize
    if self.impl.data.size ~= 0 then
      cap = self.impl.data.size * 2
    else
      cap = 2
    end
    self.impl.data = allocator.spanrealloc(self.impl.data, cap)
  end

  function ArrayTableT:reserve(n: usize <autocast>)
    self:init()
    local cap: usize = n + 1
    if self.impl.data.size < cap then
      self.impl.data = allocator.spanrealloc(self.impl.data, cap)
    end
  end

  function ArrayTableT:resize(n: usize <autocast>, v: T)
    self:init()
    if n > self.impl.size then
      self:reserve(n)
      for i=self.impl.size+1,<n do
        self.impl.data[i+1] = v
      end
      self.impl.size = n
    end
  end

  function ArrayTableT:clear()
    if likely(self.impl) then
      self.impl.size = 0
      if likely(self.impl.data.size > 0) then
        memory.zero(&self.impl.data[0], #T)
      end
    end
  end

  function ArrayTableT:push(v: T) <inline>
    self:init()
    self.impl.size = self.impl.size + 1
    if unlikely(self.impl.size + 1 >= self.impl.data.size) then
      self:_grow()
    end
    self.impl.data[self.impl.size] = v
  end

  function ArrayTableT:pop(): T <inline>
    check(self.impl and self.impl.size > 0, 'arraytable.pop: length is 0')
    local i: usize = self.impl.size
    self.impl.size = self.impl.size - 1
    return self.impl.data[i]
  end

  function ArrayTableT:__atindex(i: usize <autocast>): T* <inline>
    self:init()
    if unlikely(i > self.impl.size) then
      check(i == self.impl.size + 1, 'arraytable.at: index out of range')
      self.impl.size = self.impl.size + 1
    end
    if unlikely(self.impl.size + 1 > self.impl.data.size) then
      self:_grow()
      memory.zero(&self.impl.data[i], #T)
    end
    return &self.impl.data[i]
  end

  function ArrayTableT:__len(): isize <inline>
    if unlikely(not self.impl) then
      return 0
    end
    return (@isize)(self.impl.size)
  end

  function ArrayTableT.__convert(values: convertible_concept): ArrayTableT <inline>
    local self: ArrayTableT
    local len: usize = (@usize)(#values)
    self:reserve(len)
    self.impl.size = len
    memory.zero(&self.impl.data[0], #T)
    for i:usize=1,len do
      self.impl.data[i] = values[i-1]
    end
    return self
  end

  ## return ArrayTableT
## end))

global myarraytable = #[generic(myarraytable)]#
