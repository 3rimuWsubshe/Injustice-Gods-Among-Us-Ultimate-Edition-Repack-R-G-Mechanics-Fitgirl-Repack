--TODO: lazy functions to make it generic
--TODO: record metamethods

## strict = true
## unitname = 'nelua'

require 'allocators.gc_allocator'

local allocator = @gc_allocator

## local memoize = require 'nelua.utils.memoize'
## myarraytable = hygienize(memoize(function(T)
  local T = @#[T]#
  local ArrayTableImplT <codename #['nelua_ArrayTableImpl_'..T.name]#> = @record {
    size: usize,
    data: span(T)
  }
  global ArrayTableT <codename #['nelua_ArrayTable_'..T.name]#> = @record{
    impl: ArrayTableImplT*
  }

  function ArrayTableT:init() <inline>
    if unlikely(not self.impl) then
      self.impl = (@ArrayTableImplT*)(allocator.alloc0(#ArrayTableImplT))
    end
  end

  function ArrayTableT:reset()
    if likely(self.impl) then
      allocator.spandealloc(self.impl.data)
      allocator.dealloc(self.impl)
      self.impl = nilptr
    end
  end

  function ArrayTableT:_grow() <noinline>
    local cap: usize
    if self.impl.data.size ~= 0 then
      cap = self.impl.data.size * 2
    else
      cap = 2
    end
    self.impl.data = allocator.spanrealloc(self.impl.data, cap)
  end

  function ArrayTableT:reserve(n: usize <autocast>) <noinline>
    self:init()
    local cap = n + 1
    if self.impl.data.size < cap then
      self.impl.data = allocator.spanrealloc(self.impl.data, cap)
    end
  end

  function ArrayTableT:resize(n: usize <autocast>, v: T)
    self:init()
    local addn = n - self.impl.size
    if addn > 0 then
      self:reserve(n)
      for i=self.impl.size+1,<n do
        self.impl.data[i+1] = v
      end
      self.impl.size = n
    end
  end

  function ArrayTableT:clear()
    if likely(self.impl) then
      self.impl.size = 0
      if likely(self.impl.data.size > 0) then
        memory.zero(&self.impl.data[0], #T)
      end
    end
  end

  function ArrayTableT:push(v: T) <inline>
    self:init()
    self.impl.size = self.impl.size + 1
    if unlikely(self.impl.size + 1 >= self.impl.data.size) then
      self:_grow()
    end
    self.impl.data[self.impl.size] = v
  end

  function ArrayTableT:pop(): T <inline>
    check(self.impl and self.impl.size > 0, 'arraytable.pop: length is 0')
    local i = self.impl.size
    self.impl.size = self.impl.size - 1
    return self.impl.data[i]
  end

  function ArrayTableT:at(i: usize <autocast>): T* <inline>
    self:init()
    if unlikely(i > self.impl.size) then
      check(i == self.impl.size + 1, 'arraytable.at: index out of range')
      self.impl.size = self.impl.size + 1
    end
    if unlikely(self.impl.size + 1 > self.impl.data.size) then
      self:_grow()
      memory.zero(&self.impl.data[i], #T)
    end
    return &self.impl.data[i]
  end

  function ArrayTableT:set(i: usize <autocast>, v: T) <inline>
    self:init()
    if unlikely(i > self.impl.size) then
      check(i == self.impl.size + 1, 'arraytable.at: index out of range')
      self.impl.size = self.impl.size + 1
    end
    if unlikely(self.impl.size + 1 > self.impl.data.size) then
      self:_grow()
    end
    self.impl.data[i] = v
  end

  function ArrayTableT:get(i: usize <autocast>): T <inline>
    if unlikely(i == 0 and (not self.impl or self.impl.data.size == 0)) then
      local v: T
      return v
    else
      check(self.impl and i <= self.impl.size, 'arraytable.get: index out of range')
      return self.impl.data[i]
    end
  end

  function ArrayTableT:len(): isize <inline>
    if unlikely(not self.impl) then
      return 0
    end
    return (@isize)(self.impl.size)
  end

  ## return ArrayTableT
## end))
