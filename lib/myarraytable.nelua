--TODO: lazy functions to make it generic
--TODO: record metamethods

## strict = true
## unitname = 'nelua'

require 'memory'

local T = @byte
local ArrayTableObj = @record{
  size: usize,
  data: span(T)
}

function ArrayTableObj.create(): ArrayTableObj*
  return (@ArrayTableObj*)(memory.new(ArrayTableObj))
end

function ArrayTableObj:reserve(cap: usize)
  memory.spanrealloc0(self.data, cap + 1)
  if unlikely(self.data.size == 0) then
    local t: T
    self.data[0] = t
  end
  self.data.size = cap
end

function ArrayTableObj:grow()
  local cap = self.data.size == 0 and 1_usize or (self.data.size << 1)
  self:reserve(cap)
end

function ArrayTableObj:resize(n: usize, v: T)
  local addn = n - self.size
  if addn > 0 then
    self:reserve(n)
    for i=self.size+1,<n do
      self.data[i+1] = v
    end
    self.size = n
  end
end

function ArrayTableObj:push(v: T)
  self.size = self.size + 1
  if unlikely(self.size > self.data.size) then
    self:grow()
  end
  self.data[self.size] = v
end

function ArrayTableObj:pop(): T
  if unlikely(self.size == 0) then
    error 'ArrayTable_pop: length is 0'
  end
  local i = self.size
  self.size = self.size - 1
  return self.data[i]
end

function ArrayTableObj:at(i: usize): T*
  if unlikely(i > self.size) then
    if unlikely(i ~= self.size + 1) then
      error 'ArrayTable_at: index out of range'
    end
    self.size = self.size + 1
    if unlikely(self.size > self.data.size) then
      self:grow()
    end
  elseif unlikely(i == 0 and self.data.size == 0) then
    self:grow()
  end
  return &self.data[i]
end

function ArrayTableObj:get(i: usize): T*
  if unlikely(i > self.size) then
    error 'ArrayTable_get: index out of range'
  elseif unlikely(i == 0 and self.data.size == 0) then
    self:grow()
  end
  return &self.data[i]
end

function ArrayTableObj:length(): usize
  return self.size
end

global myarraytable = @ArrayTableObj*
