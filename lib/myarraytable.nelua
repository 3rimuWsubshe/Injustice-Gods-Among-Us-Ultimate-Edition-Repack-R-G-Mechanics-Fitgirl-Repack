--TODO: lazy functions to make it generic

## strict = true
## unitname = 'nelua'

## local memoize = require 'nelua.utils.memoize'
## myarraytable = hygienize(memoize(function(T, allocator)
  ## if allocator then
  local allocator = #[allocator]#
  ## else
  require 'allocators.gc_allocator'
  local allocator = @gc_allocator
  ## end

  local an_array_of_T = #[concept(function(x)
    if x.type:is_table() then
      return types.ArrayType(nil, T, #x.node[1])
    elseif x.type:is_array_of(T) then
      return true
    end
  end)]#

  local T = @#[T]#
  local ArrayTableImplT <codename #['nelua_ArrayTableImpl_'..T.name]#> = @record {
    size: usize,
    data: span(T)
  }
  local ArrayTableT <codename #['nelua_ArrayTable_'..T.name]#> = @record{
    impl: ArrayTableImplT*
  }

  function ArrayTableT:init() <inline>
    if unlikely(not self.impl) then
      self.impl = (@ArrayTableImplT*)(allocator.alloc0(#ArrayTableImplT))
    end
  end

  function ArrayTableT.create(): ArrayTableT <inline>
    local self: ArrayTableT
    self:init()
    return self
  end

  function ArrayTableT:reset()
    if likely(self.impl) then
      allocator.spandealloc(self.impl.data)
      allocator.dealloc(self.impl)
      self.impl = nilptr
    end
  end

  function ArrayTableT:_grow()
    local cap: usize
    if self.impl.data.size ~= 0 then
      cap = self.impl.data.size * 2
    else
      cap = 2
    end
    self.impl.data = allocator.spanrealloc(self.impl.data, cap)
  end

  function ArrayTableT:reserve(n: usize <autocast>)
    self:init()
    local cap = n + 1
    if self.impl.data.size < cap then
      self.impl.data = allocator.spanrealloc(self.impl.data, cap)
    end
  end

  function ArrayTableT:resize(n: usize <autocast>, v: T)
    self:init()
    local addn = n - self.impl.size
    if addn > 0 then
      self:reserve(n)
      for i=self.impl.size+1,<n do
        self.impl.data[i+1] = v
      end
      self.impl.size = n
    end
  end

  function ArrayTableT:clear()
    if likely(self.impl) then
      self.impl.size = 0
      if likely(self.impl.data.size > 0) then
        memory.zero(&self.impl.data[0], #T)
      end
    end
  end

  function ArrayTableT:push(v: T) <inline>
    self:init()
    self.impl.size = self.impl.size + 1
    if unlikely(self.impl.size + 1 >= self.impl.data.size) then
      self:_grow()
    end
    self.impl.data[self.impl.size] = v
  end

  function ArrayTableT:pop(): T <inline>
    check(self.impl and self.impl.size > 0, 'arraytable.pop: length is 0')
    local i = self.impl.size
    self.impl.size = self.impl.size - 1
    return self.impl.data[i]
  end

  function ArrayTableT:__assign(values: an_array_of_T)
    self:reserve(#values)
    memory.zero(&self.impl.data[0], #T)
    memory.copy(&self.impl.data[1], &values[0], #values * #T)
  end

  function ArrayTableT:__atindex(i: usize <autocast>): T* <inline>
    self:init()
    if unlikely(i > self.impl.size) then
      check(i == self.impl.size + 1, 'arraytable.at: index out of range')
      self.impl.size = self.impl.size + 1
    end
    if unlikely(self.impl.size + 1 > self.impl.data.size) then
      self:_grow()
      memory.zero(&self.impl.data[i], #T)
    end
    return &self.impl.data[i]
  end

  function ArrayTableT:__len(): isize <inline>
    if unlikely(not self.impl) then
      return 0
    end
    return (@isize)(self.impl.size)
  end

  ## return ArrayTableT
## end))
