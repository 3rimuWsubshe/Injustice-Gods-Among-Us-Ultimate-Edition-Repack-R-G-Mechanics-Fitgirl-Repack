--TODO: lazy functions to make it generic
--TODO: span class
--TODO: record metamethods

## strict = true

require 'memory'

local T = @byte
local myarraytableobj <codename 'myarraytable'> = @record{
  len: usize,
  cap: usize,
  data: span(T)
}
local myarraytable = @myarraytableobj*

function myarraytable.create(): myarraytable
  return @myarraytable(memory.alloc(@usize(#myarraytableobj)))
end

function myarraytable:reserve(cap: usize)
  memory.realloc(self.data, (cap + 1_usize) * @usize(#T))
  if unlikely(not data) then
    error 'myarraytable_reserve: not enough memory'
  end
  if unlikely(self.cap == 0) then
    local t: T
    data[0] = t
  end
  self.data = data
  self.cap = cap
end

function myarraytable:grow()
  local cap = self.cap == 0 and 1_usize or (self.cap << 1_usize)
  self:reserve(cap)
end

function myarraytable:resize_zero(n: usize)
  local addn = n - self.len
  if addn > 0 then
    self:reserve(n)
    memory.memset(span{&self.data[self.len+1], addn}, 0)
    self.len = n
  end
end

function myarraytable:resize(n: usize, v: T)
  local addn = n - self.len
  if addn > 0 then
    self:reserve(n)
    for i=self.len+1,<n do
      self.data[i+1] = v
    end
    self.len = n
  end
end

function myarraytable:push(v: T)
  self.len = self.len + 1
  if unlikely(self.len > self.cap) then
    self:grow()
  end
  self.data[self.len] = v
end

function myarraytable:pop(): T
  if unlikely(self.len == 0) then
    error 'myarraytable_pop: length is 0'
  end
  local i = self.len
  self.len = self.len - 1
  return self.data[i]
end

function myarraytable:at(i: usize): T*
  if unlikely(i > self.len) then
    if unlikely(i ~= self.len + 1) then
      error 'myarraytable_at: index out of range'
    end
    self.len = self.len + 1
    if unlikely(self.len > self.cap) then
      self:grow()
    end
  elseif unlikely(i == 0 and self.cap == 0) then
    self:grow()
  end
  return &self.data[i]
end

function myarraytable:get(i: usize): T*
  if unlikely(i > self.len) then
    error 'myarraytable_get: index out of range'
  elseif unlikely(i == 0 and self.cap == 0) then
    self:grow()
  end
  return &self.data[i]
end

function myarraytable:length(): usize
  return self.len
end

-- tests
local t = myarraytable.create()
assert(t:length() == 0)
assert($t:at(0) == 0)
assert(t:length() == 0)
local i = t:at(0); $i = 1
assert($t:get(0) == 1)
t:push(0xf)
assert($t:get(1) == 0xf)
assert(t:length() == 1)
t:pop()
assert(t:length() == 0)