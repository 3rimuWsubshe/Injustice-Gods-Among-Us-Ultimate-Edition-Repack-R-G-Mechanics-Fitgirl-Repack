##[[
strict = true
nohashcodenames = true
modname = 'nelua'
]]

global math = @record{}

-- constants
global math.pi: float64 <comptime> = 3.141592653589793
global math.huge: float64 <const,cimport'HUGE_VAL',nodecl>
global math.maxinteger: integer <comptime> = 9223372036854775807
global math.mininteger: integer <comptime> = -9223372036854775808

-- compile time utilities
##[[
local function check_arithmetic(...)
  for i=1,select('#',...) do
    local x = select(i,...)
    staticassert(x.type:is_arithmetic(), "variable '%s' isn't an arithmetic type", x)
  end
end

local function choose_float_type(x)
  if x.type:is_float32() then
    return primtypes.float32
  else
    return primtypes.float64
  end
end
]]

-- import C math functions with 1 argument
##[[
local cmathfuncs1 = {'abs','ceil','floor','sqrt','exp','log','log2','log10','acos','asin','atan','cos','sin','tan'}
local cmathrenames1 = {abs='fabs'}
for _,name in ipairs(cmathfuncs1) do
  local cname = cmathrenames1[name] or name
  local cnamef64, cnamef32 = cname, cname..'f'
  local namef64, namef32 = name..'_f64', name..'_f32'
]]
  local function #(namef64)#(x: float64): float64
    <cimport#[cnamef64]#,cinclude'<math.h>',nodecl,nosideeffect>
  end
  local function #(namef32)#(x: float32): float32
    <cimport#[cnamef32]#,cinclude'<math.h>',nodecl,nosideeffect>
  end
## end

-- import C math functions with 2 arguments
##[[
local cmathfuncs2 = {'max','min','fmod','atan2','pow'}
local cmathrenames2 = {min='fmin',max='fmax'}
for _,name in ipairs(cmathfuncs2) do
  local cname = cmathrenames2[name] or name
  local cnamef64, cnamef32 = cname, cname..'f'
  local namef64, namef32 = name..'_f64', name..'_f32'
]]
  local function #(namef64)#(x: float64, y: float64): float64
    <cimport#[cnamef64]#,cinclude'<math.h>',nodecl,nosideeffect>
  end
  local function #(namef32)#(x: float32, y: float32): float32
    <cimport#[cnamef32]#,cinclude'<math.h>',nodecl,nosideeffect>
  end
## end

-- manually import special math functions with 2 arguments
local function modf_f64(x: float64, y: float64*): float64 <cimport'modf',nodecl,nosideeffect> end
local function modf_f32(x: float32, y: float32*): float32 <cimport'modff',nodecl,nosideeffect> end

-- define common math functions with 1 argument
##[[
local mathfuncs1 = {'abs','ceil','floor','sqrt','exp','acos','asin','cos','sin','tan'}
for _,name in ipairs(mathfuncs1) do
  local namef64, namef32 = name..'_f64', name..'_f32'
]]
function math.#(name)#(x: auto) <inline,nosideeffect>
  ## check_arithmetic(x)
  ## if x.type:is_float32() then
    return #(namef32)#(x)
  ## elseif x.type:is_float() then
    return #(namef64)#(x)
  ## else
    ## if name == 'abs' then
      if x < 0 then return -x else return x end
    ## elseif name == 'ceil' or name == 'floor' then
      return x
    ## else
      return #(namef64)#(x)
    ## end
  ## end
end
## end

-- define common math functions with 2 arguments
##[[
local mathfuncs2 = { 'max', 'min', 'fmod', 'pow' }
for _,name in ipairs(mathfuncs2) do
  local namef64, namef32 = name..'_f64', name..'_f32'
]]
function math.#(name)#(x: auto, y: auto) <inline,nosideeffect>
  ## check_arithmetic(x, y)
  ## if x.type:is_float32() then
    return #(namef32)#(x, y)
  ## elseif x.type:is_float() then
    return #(namef64)#(x, y)
  ## else
    ## if name == 'min' then
      if x < y then return x else return y end
    ## elseif name == 'max' then
      if x < y then return y else return x end
    ## else
      return #(namef64)#(x, y)
    ## end
  ## end
end
## end

function math.atan(y: auto, x: auto) <inline,nosideeffect>
  ## check_arithmetic(y)
  ## if not x.type:is_nil() then
    ## check_arithmetic(x)
    ## if y.type:is_float32() and x.type:is_float32() then
      return atan2_f32(y, x)
    ## else
      return atan2_f64(y, x)
    ## end
  ## else
    ## if y.type:is_float32() then
      return atan_f32(y)
    ## else
      return atan_f64(y)
    ## end
  ## end
end

function math.log(x: auto, base: auto) <inline,nosideeffect>
  ## check_arithmetic(x)
  ## local suffix = x.type:is_float32() and '_f32' or '_f64'
  ## local log2, log10, log = 'log2'..suffix, 'log10'..suffix, 'log'..suffix
  ## if not base.type:is_nil() then
    if base == 2 then
      return #(log2)#(x)
    elseif base == 10 then
      return #(log10)#(x)
    else
      return #(log)#(x) / #(log)#(base)
    end
  ## else
    return #(log)#(x)
  ## end
end

function math.deg(x: auto) <inline,nosideeffect>
  ## check_arithmetic(x)
  local factor: #[choose_float_type(x)]# <comptime> = 180 / math.pi
  return x * factor
end

function math.rad(x: auto) <inline,nosideeffect>
  ## check_arithmetic(x)
  local factor: #[choose_float_type(x)]# <comptime> = math.pi / 180.0
  return x * factor
end

function math.modf(x: auto) <inline,nosideeffect>
  ## check_arithmetic(x)
  ## local rettype = choose_float_type(x)
  local i: #[rettype]#
  local f: #[rettype]# <noinit>
  ## if x.type:is_float32() then
    f = modf_f32(x, &i)
  ## else
    f = modf_f64(x, &i)
  ## end
  return i, f
end

function math.tointeger(x: auto) <inline,nosideeffect>
  ## if x.type:is_integral() then
    return (@integer)(x)
  ## elseif x.type:is_float() then
    local r = (@integer)(x)
    if likely(x == r) then
      return r
    else
      return nil
    end
  ## else
    return nil
  ## end
end

function math.type(x: auto) <inline,nosideeffect>
  ## if x.type:is_float() then
    return 'float'
  ## elseif x.type:is_integral() then
    return 'integer'
  ## else
    return nil
  ## end
end

function math.ult(m: auto, n: auto): boolean <inline>
  ## check_arithmetic(m, n)
  ## if m.type:is_integral() and n.type:is_integral() then
    return (@uinteger)(m) < (@uinteger)(n)
  ## elseif x.type:is_float() then
    local mi, ni = (@integer)(m), (@integer)(n)
    if likely(mi == m and ni == n) then
      return (@uinteger)(mi) < (@uinteger)(ni)
    else
      panic('math.ult: m or n has no integer representation')
    end
  ## end
end

-- Pseudo Random Number Generator based on xoshiro256**
local xoshiro256 = @record{state: uint64[4]}

local function rotl(x: uint64, n: int32) <inline,nosideeffect>
  return (x << n) | (x >> (64 - n))
end

function xoshiro256:nextrand(): uint64
  local state: uint64[4] = {
    self.state[0],
    self.state[1],
    self.state[2] ~ self.state[0],
    self.state[3] ~ self.state[1]
  }
  local res = rotl(state[1] * 5, 7) * 9
  self.state[0] = state[0] ~ state[3]
  self.state[1] = state[1] ~ state[2]
  self.state[2] = state[2] ~ (state[1] << 17)
  self.state[3] = rotl(state[3], 45)
  return res
end

function xoshiro256:random(): float64
  local FLOAT64_MANT_DIGS <comptime> = 53
  local rv = self:nextrand()
  local v = rv >> (64_i32 - FLOAT64_MANT_DIGS)
  return v / (1_uint64 << FLOAT64_MANT_DIGS)
end

function xoshiro256:seed(a: uint64, b: uint64)
  self.state[0] = a
  self.state[1] = 0xff
  self.state[2] = b
  self.state[3] = 0
  for i=0,<16 do
    self:nextrand()
  end
end

-- pre initialize default random generator
local default_random = xoshiro256{state={
  0x65CE039BAEBE74B4, 0x4911ADA153B51EEF, 0xFB71FBB497C00950, 0xF83CCF6AC1B74755
}}

function math.randomseed(x: auto) <inline>
  ## check_arithmetic(x)
  default_random:seed((@uint64)(x), 0)
end

function math.random(m: auto, n: auto) <inline>
  local r: number = default_random:random()
  ## if not m.type:is_nil() and not n.type:is_nil() then
    ## check_arithmetic(m, n)
    local low: integer, up: integer = (@integer)(m), (@integer)(n)
    if not likely(low < up) then
      panic("random: interval is empty")
    elseif not likely(low >= 0 or up < math.maxinteger + low) then
      panic("random: interval too large")
    end
    r = r * ((@number)(up - low) + 1.0)
    return (@integer)(r) + low
  ## elseif not m.type:is_nil() then
    ## check_arithmetic(m)
    local low: integer = (@integer)(m)
    r = r * (@number)(low)
    return (@integer)(r)
  ## else
    return r
  ## end
end

-----------------------------------------------------------------------
-- tests

-- test utilities
local function asserteq(x: number, y: number)
  assert(math.abs(x - y) < 1e-7)
end
local e: float64 <comptime> = 2.718281828459045
local e_f32: float32 <comptime> = 2.718281828459045_f32

-- constants
assert(math.min(math.huge, -math.huge) == -math.huge)
assert(math.max(math.huge, -math.huge) == math.huge)

-- float64
assert(math.abs(-1.0) == 1.0) assert(math.abs(1.0) == 1.0)
assert(math.ceil(0.0) == 0.0) assert(math.ceil(-1.0) == -1.0)
assert(math.ceil(1.1) == 2.0) assert(math.ceil(-1.1) == -1.0)
assert(math.floor(0.0) == 0.0) assert(math.floor(-1.0) == -1.0)
assert(math.floor(1.1) == 1.0) assert(math.floor(-1.1) == -2.0)
assert(math.min(1.0, -1.0) == -1.0) assert(math.min(-1.0, 1.0) == -1.0)
assert(math.max(1.0, -1.0) == 1.0) assert(math.max(-1.0, 1.0) == 1.0)
asserteq(math.acos(-1.0), math.pi) asserteq(math.acos(1.0), 0)
asserteq(math.asin(0.0), 0.0) asserteq(math.asin(1.0), math.pi/2.0)
asserteq(math.atan(0.0), 0.0) asserteq(math.atan(1.0), math.pi/4.0)
asserteq(math.atan(0.0, -1.0), math.pi)
asserteq(math.atan(-1.0, -1.0), -math.pi*3.0/4.0)
asserteq(math.cos(math.pi), -1.0) asserteq(math.cos(0.0), 1.0)
asserteq(math.sin(math.pi/2.0), 1.0) asserteq(math.sin(0.0), 0.0)
asserteq(math.tan(math.pi/4.0), 1.0) asserteq(math.tan(0.0), 0.0)
asserteq(math.sqrt(4.0), 2.0) asserteq(math.sqrt(9.0), 3.0)
asserteq(math.exp(0.0), 1.0) asserteq(math.exp(1.0), e)
asserteq(math.log(1.0), 0.0) asserteq(math.log(e), 1.0)
asserteq(math.log(1e8, 10.0), 8.0) asserteq(math.log(1e-8, 10.0), -8.0)
asserteq(math.log(1024.0, 2.0), 10.0) asserteq(math.log(1.0/1024.0, 2.0), -10.0)
asserteq(math.pow(2.0, 10.0), 1024.0) asserteq(math.pow(2.0, -10.0), 1.0/1024.0)
asserteq(math.fmod(5.0, 2.0), 1.0) asserteq(math.fmod(2.3, 5.7), 2.3)
asserteq(math.deg(math.pi / 2.0), 90.0) asserteq(math.deg(0.0), 0.0)
asserteq(math.rad(90.0), math.pi / 2.0) asserteq(math.rad(0.0), 0.0)

-- float32
global math.pi_f32 = (@float32)(math.pi)
assert(math.abs(-1.0_f32) == 1.0_f32) assert(math.abs(1.0_f32) == 1.0_f32)
assert(math.ceil(0.0_f32) == 0.0_f32) assert(math.ceil(-1.0_f32) == -1.0_f32)
assert(math.ceil(1.1_f32) == 2.0_f32) assert(math.ceil(-1.1_f32) == -1.0_f32)
assert(math.floor(0.0_f32) == 0.0_f32) assert(math.floor(-1.0_f32) == -1.0_f32)
assert(math.floor(1.1_f32) == 1.0_f32) assert(math.floor(-1.1_f32) == -2.0_f32)
assert(math.min(1.0_f32, -1.0_f32) == -1.0_f32) assert(math.min(-1.0_f32, 1.0_f32) == -1.0_f32)
assert(math.max(1.0_f32, -1.0_f32) == 1.0_f32)  assert(math.max(-1.0_f32, 1.0_f32) == 1.0_f32)
asserteq(math.acos(-1.0_f32), math.pi_f32) asserteq(math.acos(1.0_f32), 0)
asserteq(math.asin(0.0_f32), 0.0_f32) asserteq(math.asin(1.0_f32), math.pi_f32/2.0_f32)
asserteq(math.atan(0.0_f32), 0.0_f32) asserteq(math.atan(1.0_f32), math.pi_f32/4.0_f32)
asserteq(math.atan(0.0_f32, -1.0_f32), math.pi_f32)
asserteq(math.atan(-1.0_f32, -1.0_f32), -math.pi_f32*3.0_f32/4.0_f32)
asserteq(math.cos(math.pi_f32), -1.0_f32) asserteq(math.cos(0.0_f32), 1.0_f32)
asserteq(math.sin(math.pi_f32/2.0_f32), 1.0_f32) asserteq(math.sin(0.0_f32), 0.0_f32)
asserteq(math.tan(math.pi_f32/4.0_f32), 1.0_f32) asserteq(math.tan(0.0_f32), 0.0_f32)
asserteq(math.sqrt(4.0_f32), 2.0_f32) asserteq(math.sqrt(9.0_f32), 3.0_f32)
asserteq(math.exp(0.0_f32), 1.0_f32)
asserteq(math.exp(1.0_f32), e_f32)
asserteq(math.log(1.0_f32), 0.0_f32) asserteq(math.log(e_f32), 1.0_f32)
asserteq(math.log(1e8_f32, 10.0_f32), 8.0_f32) asserteq(math.log(1e-8_f32, 10.0_f32), -8.0_f32)
asserteq(math.log(1024.0_f32, 2.0_f32), 10.0_f32) asserteq(math.log(1.0_f32/1024.0_f32, 2.0_f32), -10.0_f32)
asserteq(math.pow(2.0_f32, 10.0_f32), 1024.0_f32) asserteq(math.pow(2.0_f32, -10.0_f32), 1.0_f32/1024.0_f32)
asserteq(math.fmod(5.0_f32, 2.0_f32), 1.0_f32) asserteq(math.fmod(2.3_f32, 5.7_f32), 2.3_f32)
asserteq(math.deg(math.pi_f32 / 2.0_f32), 90.0_f32) asserteq(math.deg(0.0_f32), 0.0_f32)
asserteq(math.rad(90.0_f32), math.pi / 2.0_f32) asserteq(math.rad(0.0_f32), 0.0_f32)

-- integer
assert(math.abs(-1) == 1) assert(math.abs(1) == 1)
assert(math.ceil(0) == 0) assert(math.ceil(1) == 1) assert( math.ceil(-1) == -1)
assert(math.floor(0) == 0) assert(math.floor(1) == 1) assert(math.floor(-1) == -1)
assert(math.min(1, -1) == -1) assert(math.min(-1, 1) == -1)
assert(math.max(1, -1) == 1) assert(math.max(-1, 1) == 1)
asserteq(math.acos(-1), math.pi) asserteq(math.acos(1), 0)
asserteq(math.asin(0), 0) asserteq(math.asin(1), math.pi/2)
asserteq(math.atan(0), 0) asserteq(math.atan(1), math.pi/4)
asserteq(math.atan(0, -1), math.pi)
asserteq(math.atan(-1, -1), -math.pi*3/4)
asserteq(math.cos(0), 1)
asserteq(math.sin(0), 0)
asserteq(math.tan(0), 0)
asserteq(math.sqrt(4), 2) asserteq(math.sqrt(9), 3)
asserteq(math.exp(0), 1)
asserteq(math.exp(1), e)
asserteq(math.log(1), 0) asserteq(math.log(e), 1)
asserteq(math.log(100000000, 10), 8)
asserteq(math.log(1024, 2), 10)
asserteq(math.pow(2, 10), 1024)
asserteq(math.fmod(5, 2), 1)
asserteq(math.deg(math.pi / 2), 90) asserteq(math.deg(0), 0)
asserteq(math.rad(90), math.pi / 2) asserteq(math.rad(0), 0)

-- modf
do
  local i: number, f: number
  i, f = math.modf( 4.0)  asserteq(i, 4.0)  asserteq(f, 0.0)
  i, f = math.modf( 4.5)  asserteq(i, 4.0)  asserteq(f, 0.5)
  i, f = math.modf(-4.5)  asserteq(i,-4.0)  asserteq(f,-0.5)
end
do
  local i: float32, f: float32
  i, f = math.modf( 4.0_f32)  asserteq(i, 4_f32)  asserteq(f, 0.0_f32)
  i, f = math.modf( 4.5_f32)  asserteq(i, 4_f32)  asserteq(f, 0.5_f32)
  i, f = math.modf(-4.5_f32)  asserteq(i,-4_f32)  asserteq(f,-0.5_f32)
end

-- math.tointeger
--assert(math.tointeger(1.1) == 1_integer)
--assert(math.tointeger('s') == nil)
assert(math.tointeger(1) == 1_integer)

-- math.type
assert(math.type(1) == 'integer')
assert(math.type(1_u8) == 'integer')
assert(math.type(1.0) == 'float')
assert(math.type(1.0_f32) == 'float')
--assert(math.type('s') == nil)

-- math.ult
assert(math.ult(math.maxinteger, math.mininteger))

-- random
math.randomseed(0)
do
  for i=1,10 do
    local x,y,z = math.random(), math.random(10), math.random(-10,0)
    assert(x >= 0 and x <= 1)
    assert(y >= 0 and y <= 10)
    assert(z >= -10 and z <= 0)
  end
end
