--[[
The list library provides a double linked list container.

A double linked list is a dynamic sized container that supports
constant time insertion and removal from anywhere in the container.

However doubled linked lists don't support fast random access,
use a vector or sequence in that case.
]]

require 'memory'
require 'iterators'

## local make_listT = generalize(function(T, Allocator)
  ## static_assert(traits.is_type(T), "invalid type '%s'", T)
  ## if not Allocator then
  require 'allocators.default'
  ## Allocator = DefaultAllocator
  ## end

  local Allocator: type = #[Allocator]#
  local T: type = @#[T]#

  -- List node record defined when instantiating the generic `list`.
  local listnodeT: type <nickname #[string.format('listnode(%s)',T)]#> = @record {
    prev: *listnodeT,
    next: *listnodeT,
    value: T
  }

  -- List record defined when instantiating the generic `list`.
  local listT: type <nickname #[string.format('list(%s)',T)]#> = @record{
    front: *listnodeT, -- list begin
    back: *listnodeT, -- list end
    allocator: Allocator
  }

  ##[[
  local listT = listT.value
  listT.is_list = true
  listT.is_container = true
  listT.subtype = T
  ]]

  --[[
  Creates a list using a custom allocator instance.
  This is only to be used when not using the default allocator.
  ]]
  function listT.make(allocator: Allocator): listT
    local l: listT
    l.allocator = allocator
    return l
  end

  --[[
  Remove all elements from the list.

  *Complexity*: O(n).
  ]]
  function listT:clear(): void
    local it: *listnodeT = self.front
    while it do
      local next: *listnodeT = it.next
      self.allocator:delete(it)
      it = next
    end
    self.front = nilptr
    self.back = nilptr
  end

  --[[
  Resets the list to zeroed state, freeing all used resources.

  This is more useful to free resources when not using the garbage collector.
  ]]
  function listT:destroy(): void
    self:clear()
    memory.zero(self, #listT)
  end

  --[[
  Inserts an element at beginning of the list.

  *Complexity*: O(1).
  ]]
  function listT:prepend(value: T): void
    local node: *listnodeT = self.allocator:new(@listnodeT)
    node.prev = nilptr
    node.next = self.front
    node.value = value
    if likely(self.front) then
      self.front.prev = node
    end
    if unlikely(not self.back) then
      self.back = node
    end
    self.front = node
  end

  --[[
  Adds an element at the end of the list.

  *Complexity*: O(1).
  ]]
  function listT:append(value: T): void
    local node: *listnodeT = self.allocator:new(@listnodeT)
    node.prev = self.back
    node.next = nilptr
    node.value = value
    if likely(self.back) then
      self.back.next = node
    end
    if unlikely(not self.front) then
      self.front = node
    end
    self.back = node
  end

  --[[
  Find an element in the list, returning it's node reference when found.

  *Complexity*: O(1).
  ]]
  function listT:find(value: T): *listnodeT
    local it: *listnodeT = self.front
    while it do
      if it.value == value then
        return it
      end
      it = it.next
    end
    return nilptr
  end

  --[[
  Erases a node from the list.
  If the node not in the list, then throws a runtime error on debug builds.

  *Complexity*: O(1).
  ]]
  function listT:erase(node: *listnodeT): *listnodeT
    check(node ~= nilptr, 'attempt to erase a nilptr node')
    if node == self.front then
      self.front = node.next
    end
    if node == self.back then
      self.back = node.prev
    end
    if node.prev then
      node.prev.next = node.next
    end
    if node.next then
      node.next.prev = node.prev
    end
    local next: *listnodeT = node.next
    self.allocator:delete(node)
    return next
  end

  --[[
  Removes the first element and returns it.
  If the list is empty, then throws a runtime error on debug builds.

  *Complexity*: O(1).
  ]]
  function listT:popfront(): T
    check(self.front ~= nilptr, 'list is empty')
    local node: *listnodeT = self.front
    local ret: T = node.value
    self.front = node.next
    if likely(self.front) then
      self.front.prev = nilptr
    end
    if unlikely(self.back == node) then
      self.back = nilptr
    end
    self.allocator:delete(node)
    return ret
  end

  --[[
  Removes the first element and returns it.
  If the list is empty, then throws a runtime error on debug builds.

  *Complexity*: O(1).
  ]]
  function listT:popback(): T
    check(self.back ~= nilptr, 'list is empty')
    local node: *listnodeT = self.back
    local ret: T = node.value
    self.back = node.prev
    if likely(self.back) then
      self.back.next = nilptr
    end
    if unlikely(self.front == node) then
      self.front = nilptr
    end
    self.allocator:delete(node)
    return ret
  end

  -- Returns whether the list is empty.
  function listT:empty(): boolean
    return self.front == nilptr
  end

  --[[
  Returns the number of elements in the list.

  *Complexity*: O(n).
  ]]
  function listT:__len(): isize
    local count: isize = 0
    local it: *listnodeT = self.front
    while it do
      count = count + 1
      it = it.next
    end
    return count
  end

  --[[
  Returns the next node of the list and its element.
  Used with `pairs()` iterator.
  ]]
  function listT:__next(node: *listnodeT): (boolean, *listnodeT, T) <inline>
    local nextnode: *listnodeT
    if unlikely(node == nilptr) then
      nextnode = self.front
    else
      nextnode = node.next
    end
    if unlikely(nextnode == nilptr) then
      return false, nilptr, T()
    end
    return true, nextnode, nextnode.value
  end

  --[[
  Returns the next node of the list and its element by reference.
  Used with `pairs()` iterator.
  ]]
  function listT:__mnext(node: *listnodeT): (boolean, *listnodeT, *T) <inline>
    local nextnode: *listnodeT
    if unlikely(node == nilptr) then
      nextnode = self.front
    else
      nextnode = node.next
    end
    if unlikely(nextnode == nilptr) then
      return false, nilptr, nilptr
    end
    return true, nextnode, &nextnode.value
  end

  -- Allow using `pairs()` to iterate the container.
  function listT:__pairs() <inline>
    return listT.__next, self, nilptr
  end

  -- Allow using `mpairs()` to iterate the container.
  function listT:__mpairs() <inline>
    return listT.__mnext, self, nilptr
  end

  ## return listT
## end)

--[[
Generic used to instantiate a list type in the form of `list(T, Allocator)`.

Argument `T` is the value type that the list will store.
Argument `Allocator` is an allocator type for the container storage,
in case absent then then `DefaultAllocator` is used.
]]
global list: type = #[make_listT]#
