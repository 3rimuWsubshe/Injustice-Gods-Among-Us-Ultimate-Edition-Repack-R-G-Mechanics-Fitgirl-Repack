--[[
GC Allocator

This is an allocator that uses a simple mark and sweep garbage collector.
It is a conservative garbage collector, that is, it scans the stack/heap memory
marking pointers without references to be freed once the memory grows too much.
]]

require 'span'
require 'allocators.general'
require 'hashmap'
require 'vector'

##[[
if pragmas.nogc then
  static_error 'allocators.gc was required while GC is explicitly disabled'
end
cemitdecl[=[
#if defined(__has_feature)
#if __has_feature(address_sanitizer)
#define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
#elif __has_feature(memory_sanitizer)
#define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_memory))
#endif
#elif defined(__SANITIZE_ADDRESS__)
#define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
#endif
#ifndef NELUA_GC_NO_SANITIZE
#define NELUA_GC_NO_SANITIZE
#endif
]=]
]]

local jmp_buf: type <cimport,nodecl,cinclude'<setjmp.h>',cincomplete> = @record{}
local function setjmp(env: jmp_buf): void <cimport,cinclude'<setjmp.h>',nodecl> end

-- Utilities

local function hasflag(flags: usize, flag: usize): boolean <inline>
  return flags & flag ~= 0
end

local function align_forward(addr: usize, align: usize): usize <inline>
  return (addr + (align-1)) & ~(align-1)
end

local UINTPTR_MAX: usize <cimport'UINTPTR_MAX',cinclude'<stdint.h>',nodecl>
local DEFAULT_PAUSE: usize <comptime> = 200

-- GCFlags

global GCFlags: type = @enum(usize) {
  MARK = 1, -- marked for collection, used internally
  ROOT = 2, -- should not never deallocate
  LEAF = 4, -- contains no pointers to other allocations inside
  EXTERN = 8, -- external allocation, thus we should to deallocate when collecting
}

-- GCItem

global GCFinalizerCallback: type = @function(pointer, pointer): void

global GCItem: type = @record{
  flags: usize,
  size: usize,
  ptr: pointer,
  finalizer: GCFinalizerCallback,
  userdata: pointer,
}

function GCItem:mark(): void <inline>
  self.flags = self.flags | GCFlags.MARK
end

function GCItem:unmark(): void <inline>
  self.flags = self.flags & ~GCFlags.MARK
end

function GCItem:ismarked(): boolean <inline>
  -- root items are always marked
  return hasflag(self.flags, GCFlags.MARK | GCFlags.ROOT)
end

function GCItem:isleaf(): boolean <inline>
  return hasflag(self.flags, GCFlags.LEAF)
end

function GCItem:isroot(): boolean <inline>
  return hasflag(self.flags, GCFlags.ROOT)
end

function GCItem:isdealloc(): boolean <inline>
  return not hasflag(self.flags, GCFlags.EXTERN)
end

-- GC

global GC: type = @record{
  running: boolean,
  collecting: boolean,
  pause: usize,
  membytes: usize,
  lastmembytes: usize,
  minaddr: usize,
  maxaddr: usize,
  bottom: pointer,
  frees: vector(pointer, GeneralAllocator),
  items: hashmap(pointer, GCItem, nil, GeneralAllocator),
}

global gc: GC

function GC:unregister(ptr: pointer, finalize: facultative(boolean)): boolean
  if unlikely(not ptr) then return false end
  local item: GCItem = self.items:remove(ptr)
  if unlikely(item.ptr ~= ptr) then return false end -- not found
  self.membytes = self.membytes - item.size -- update mem
  -- remove from to be free items
  for i:usize=0,<self.frees.size do
    if self.frees[i] == ptr then
      self.frees[i] = nilptr
      break
    end
  end
  -- finalize
  ## if finalize.type.is_boolean then
  if finalize then
    if item.finalizer then -- finalize
      item.finalizer(ptr, item.userdata)
    end
  end
  ## end
  return true
end

function GC:_markptrs(low: usize, high: usize): void <cqualifier'NELUA_GC_NO_SANITIZE'>
  local minaddr: usize, maxaddr: usize = self.minaddr, self.maxaddr
  local items: auto = &self.items
  for memaddr: usize=low,<high,#@pointer do
    local addr: usize = $(@*usize)(memaddr)
    if addr >= minaddr and addr <= maxaddr then
      local item: *GCItem = items:peek((@pointer)(addr))
      if item and not item:ismarked() then -- unmarked reference found
        item:mark()
        if not item:isleaf() then -- don't scan leafs
          self:_markptrs(addr, addr + item.size)
        end
      end
    end
  end
end

function GC:_unmarkall(): void <noinline>
  for ptr: pointer, item: *GCItem in mpairs(self.items) do
    item:unmark()
  end
end

function GC:_markroot(): void <noinline>
  -- TODO: optimize to traverse only root items?
  for ptr: pointer, item: *GCItem in mpairs(self.items) do
    if item:isroot() then
      local addr: usize = (@usize)(ptr)
      self:_markptrs(addr, addr + item.size)
    end
  end
end

local function gc_markstackinner(self: *GC): void
  local stk: pointer <volatile> -- don't optimize away
  local low: usize = (@usize)(self.bottom)
  local high: usize = (@usize)(&stk)
  if high < low then low, high = high, low end
  self:_markptrs(low, high)
end

function GC:_markstack(): void <noinline>
## if not ccinfo.is_wasm then
  -- dump CPU registers into the stack, to scan them
  local regs: jmp_buf
  setjmp(regs)
  -- scan stack
  local markstackinner: auto <volatile> = gc_markstackinner -- avoid inline
  markstackinner(self)
## end
end

function GC:_sweep(): void <noinline>
  -- collect all unmarked items
  local finalize: boolean = false
  for ptr: pointer, item: *GCItem in mpairs(self.items) do
    if not item:ismarked() then
      self.frees:push(ptr)
      if not finalize and item.finalizer then
        finalize = true
      end
    end
  end
  -- call all finalizers before deallocating
  if finalize then
    for i: integer, ptr: pointer in ipairs(self.frees) do
      if ptr then -- it's possible that the item was removed while iterating
        local item: *GCItem = self.items:peek(ptr)
        check(item, 'gc item not found to finalize')
        if item.finalizer then
          local finalizer: GCFinalizerCallback = item.finalizer
          item.finalizer = nilptr -- avoid finalizing again
          finalizer(ptr, item.userdata)
        end
      end
    end
  end
  -- deallocate
  for i: integer, ptr: pointer in ipairs(self.frees) do
    if ptr then -- it's possible that the item was removed by a finalizer
      local item: GCItem = self.items:remove(ptr)
      check(item.ptr == ptr, 'gc item not found to deallocate')
      self.membytes = self.membytes - item.size -- update mem
      if item:isdealloc() then -- deallocate
        general_allocator:dealloc(ptr)
      end
    end
  end
  self.frees:clear()
end

function GC:collect(): void
  -- avoid collecting when already collecting, can happen while calling finalizers
  if self.collecting then return end
  self.collecting = true
  -- mark items
  self:_unmarkall()
  self:_markroot()
  self:_markstack()
  -- sweep items
  self:_sweep()
  -- shrink items
  if self.items:loadfactor() < 0.25 then
    self.items:rehash(0)
  end
  -- update last collection memory bytes
  self.lastmembytes = self.membytes
  -- collect finished
  self.collecting = false
end

function GC:_registerstatics(): void
  ## local emit_mark_statics = hygienize(function(staticsyms)
    ## for i=1,#staticsyms do
      ## local sym = staticsyms[i]
      gc:register(&#[sym]#, # #[sym.type]#, GCFlags.ROOT, nilptr, nilptr)
    ## end
  ## end)

  ##[[
  after_analyze(function()
    local symbols = {}
    local function search_scope(scope)
      for i=1,#scope.symbols do
        local sym = scope.symbols[i]
        if sym:is_on_static_storage() and
           sym.type:has_pointer() and
           not sym.cimport and
           sym.type.nickname ~= 'GC' then
          symbols[#symbols+1] = sym
        end
      end
    end
    search_scope(context.rootscope)
    for _,childscope in ipairs(context.rootscope.children) do
      search_scope(childscope)
    end
    emit_mark_statics(symbols)
  end)
  ]]
end

function GC:_maybecollect(): void
  if not self.running or self.collecting then return end
  if self.membytes == 0 then return end
  if #self.items == 0 then return end
  if self.membytes < (self.lastmembytes * self.pause) // 100 then return end
  self:collect()
end

function GC:register(ptr: pointer, size: usize, flags: usize, finalizer: GCFinalizerCallback, userdata: pointer): void
  if unlikely(not ptr) then return end
  -- small allocations that can't store pointers are always leafs
  if size < #@usize then
    flags = flags | GCFlags.LEAF
  end
  -- make item for the pointer
  local item: *GCItem = &self.items[ptr]
  check(item.ptr == nilptr, 'cannot register pointer twice')
  $item = GCItem{
    flags = flags,
    size = size,
    ptr = ptr,
    finalizer = finalizer,
    userdata = userdata,
  }
  -- update collector address bounds
  if not item:isroot() then -- skip root items, because they are always scanned
    local addr: usize = (@usize)(ptr)
    local addrhigh: usize = addr + size
    if addrhigh > self.maxaddr then self.maxaddr = addrhigh end
    if addr < self.minaddr then self.minaddr = addr end
  end
  -- add memory
  self.membytes = self.membytes + size
  self:_maybecollect()
end

function GC:reregister(ptr: pointer, newptr: pointer, newsize: usize): boolean
  check(ptr and newptr and newsize > 0, 'invalid pointer reregister arguments')
  local oldsize: usize
  if newptr == ptr then
    local item: *GCItem = self.items:peek(ptr)
    if unlikely(not item) then return false end -- not found
    oldsize = item.size
    item.size = newsize
    if newsize > oldsize then -- memory growing
      self.membytes = self.membytes + (newsize - oldsize)
      self:_maybecollect()
    elseif newsize < oldsize then -- memory shrinking
      self.membytes = self.membytes - (oldsize - newsize)
    end
  else -- moved, remove and insert item again
    local item: GCItem = self.items:remove(ptr)
    if unlikely(item.ptr ~= ptr) then return false end -- not found
    self.membytes = self.membytes - item.size -- update mem
    -- update to be free items
    for i:usize=0,<self.frees.size do
      if self.frees[i] == ptr then -- this is very unlikely (realloc on a finalized item)
        self.frees[i] = newptr
        break
      end
    end
    -- register again
    self:register(newptr, newsize, item.flags, item.finalizer, item.userdata)
  end
  return true
end

function GC:count(): number
  return self.membytes / 1024.0
end

function GC:stop(): void
  self.running = false
end

function GC:restart(): void
## if not ccinfo.is_wasm then -- cannot run automatically on emscripten
  self.running = true
## end
end

function GC:setpause(pause: integer): integer
  local oldpause: integer = self.pause
  if pause < 100 then pause = 100 end
  self.pause = pause
  return oldpause
end

function GC:isrunning(): boolean
  return self.running
end

function GC:init(stack: pointer): void
  self.bottom = stack
  self.minaddr = UINTPTR_MAX
  self.pause = DEFAULT_PAUSE
  self:_registerstatics()
  self:restart()
end

function GC:destroy(): void
  self:_unmarkall()
  self:_sweep()
  self.items:destroy()
  self.frees:destroy()
  $self = {}
end

----------------------------------------------------

## if not pragmas.nogcentry then
local function nelua_main(argc: cint, argv: *cstring): cint <cimport,nodecl> end

local function main(argc: cint, argv: *cstring): cint <entrypoint>
  gc:init(&argc)
  local inner_main: auto <volatile> = nelua_main -- avoid inline
  local ret: cint = inner_main(argc, argv)
  gc:destroy()
  return ret
end
## end

require 'allocators.allocator'

global GCAllocator = @record{}

function GCAllocator:alloc(size: usize,
                           flags: facultative(usize),
                           finalizer: facultative(GCFinalizerCallback),
                           userdata: facultative(pointer)): pointer <noinline>
  ## if flags.type.is_niltype then
  local flags: usize = 0
  ## end
  ## if finalizer.type.is_niltype then
  local finalizer: GCFinalizerCallback = nilptr
  ## end
  ## if userdata.type.is_niltype then
  local userdata: pointer = nilptr
  ## end
  local ptr: pointer = general_allocator:alloc(size)
  gc:register(ptr, size, flags, finalizer, userdata)
  return ptr
end

function GCAllocator:alloc0(size: usize,
                           flags: facultative(usize),
                           finalizer: facultative(GCFinalizerCallback),
                           userdata: facultative(pointer)): pointer <noinline>
  ## if flags.type.is_niltype then
  local flags: usize = 0
  ## end
  ## if finalizer.type.is_niltype then
  local finalizer: GCFinalizerCallback = nilptr
  ## end
  ## if userdata.type.is_niltype then
  local userdata: pointer = nilptr
  ## end
  local ptr: pointer = general_allocator:alloc0(size)
  gc:register(ptr, size, flags, finalizer, userdata)
  return ptr
end

function GCAllocator:dealloc(ptr: pointer): void <noinline>
  gc:unregister(ptr, true)
  general_allocator:dealloc(ptr)
end

function GCAllocator:realloc(ptr: pointer, newsize: usize, oldsize: usize): pointer <noinline>
  if unlikely(ptr == nilptr) then
    return self:alloc(newsize)
  elseif unlikely(newsize == 0) then
    self:dealloc(ptr)
    return nilptr
  elseif unlikely(newsize == oldsize) then
    return ptr
  else -- shrinking or growing
    local newptr: pointer = general_allocator:realloc(ptr, newsize, oldsize)
    if newptr then
      gc:reregister(ptr, newptr, newsize)
    end
    return newptr
  end
end

function GCAllocator:new(what: auto, size: facultative(usize)) <noinline>
  local T: type = #[what.type.is_type and what.value or what.type]#
  ## if size.type.is_niltype then -- new pointer
    ## if T.value.is_record and T.value.metafields.__gc then
    local function finalizer(ptr: pointer, userdata: pointer): void
      T.__gc((@*T)(ptr))
    end
    ## else
    local finalizer: GCFinalizerCallback = nilptr
    ## end
    local flags: usize = 0
    ## if not T.value:has_pointer() then
    local flags: usize = GCFlags.LEAF -- skip scanning the allocated memory
    ## end
    local ptr: *T <noinit>
    ## if what.type.is_type then
    ptr = (@*T)(gc_allocator:alloc0(#T, flags, finalizer, nilptr))
    assert(ptr ~= nilptr, 'out of memory')
    ## else
    ptr = (@*T)(gc_allocator:alloc(#T, flags, finalizer, nilptr))
    assert(ptr ~= nilptr, 'out of memory')
    memory.copy(ptr, &what, #T)
    ## end
    return ptr
  ## else -- new span
    local T: type = #[what.type.is_type and what.value or what.type]#
    local spn: span(T)
    if likely(size > 0) then
      ## if T.value.metafields.__gc then
      local function finalizer(ptr: pointer, userdata: pointer): void
        local size: usize = (@usize)(userdata)
        local data: *[0]T = (@*[0]T)(ptr)
        for i:usize=0,<size do
          data[i]:__gc()
        end
      end
      local userdata: pointer = (@pointer)(size)
      ## else
      local finalizer: GCFinalizerCallback = nilptr
      local userdata: pointer = nilptr
      ## end
      local flags: usize = 0
      ## if not T.value:has_pointer() then
      local flags: usize = GCFlags.LEAF -- skip scanning the allocated memory
      ## end
      spn.size = size
      ## if what.type.is_type then
      spn.data = (@*[0]T)(gc_allocator:alloc0(size * #T, flags, finalizer, userdata))
      assert(spn.data ~= nilptr, 'out of memory')
      ## else
      spn.data = (@*[0]T)(gc_allocator:alloc(size * #T, flags, finalizer, userdata))
      assert(spn.data ~= nilptr, 'out of memory')
      memory.spanset(spn, what)
      ## end
    end
    return spn
  ## end
end

## implement_allocator_interface(GCAllocator)

global gc_allocator: GCAllocator

global function collectgarbage(opt: overload(string,number,niltype) <comptime>)
  ## if opt.type.is_niltype or opt.value == 'collect' then
    gc:collect()
  ## elseif opt.value == 'stop' then
    gc:stop()
  ## elseif opt.value == 'restart' then
    gc:restart()
  ## elseif opt.value == 'setpause' then
    return gc:setpause(tointeger(opt))
  ## elseif opt.value == 'count' then
    return gc:count()
  ## elseif opt.value == 'isrunning' then
    return gc:isrunning()
  ## else static_error('invalid collect garbage argument %s', opt.value) end
end
