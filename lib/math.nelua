-- Math library
--
-- The math library tries to follow all math functions from Lua

global math = @record{}

global math.pi: number <comptime> = 3.1415926535897932
global math.huge: number <const,cimport'HUGE_VAL',cinclude'<math.h>',nodecl>
global math.maxinteger: integer <comptime> = #[primtypes.integer.max]#
global math.mininteger: integer <comptime> = #[primtypes.integer.min]#

-- concepts
local is_arithmetic = #[concept(function(x)
  return x.type.is_arithmetic
end)]#
local is_optional_arithmetic = #[concept(function(x)
  return x.type.is_arithmetic or x.type.is_nil
end)]#

-- compile time utilities
##[[
local function choose_float_type(x)
  if x.type.is_float32 then
    return primtypes.float32
  else
    return primtypes.float64
  end
end
]]

-- import C math functions with 1 argument
##[[
local cmathfuncs1 = {'abs','ceil','floor','sqrt','exp','log','log2','log10','acos','asin','atan','cos','sin','tan'}
local cmathrenames1 = {abs='fabs'}
for _,name in ipairs(cmathfuncs1) do
  local cname = cmathrenames1[name] or name
  local cnamef64, cnamef32 = cname, cname..'f'
  local namef64, namef32 = name..'_f64', name..'_f32'
]]
  local function #|namef64|#(x: float64): float64
    <cimport#[cnamef64]#,cinclude'<math.h>',nodecl,nosideeffect>
  end
  local function #|namef32|#(x: float32): float32
    <cimport#[cnamef32]#,cinclude'<math.h>',nodecl,nosideeffect>
  end
## end

-- import C math functions with 2 arguments
##[[
local cmathfuncs2 = {'max','min','fmod','atan2','pow'}
local cmathrenames2 = {min='fmin',max='fmax'}
for _,name in ipairs(cmathfuncs2) do
  local cname = cmathrenames2[name] or name
  local cnamef64, cnamef32 = cname, cname..'f'
  local namef64, namef32 = name..'_f64', name..'_f32'
]]
  local function #|namef64|#(x: float64, y: float64): float64
    <cimport#[cnamef64]#,cinclude'<math.h>',nodecl,nosideeffect>
  end
  local function #|namef32|#(x: float32, y: float32): float32
    <cimport#[cnamef32]#,cinclude'<math.h>',nodecl,nosideeffect>
  end
## end

-- manually import special math functions with 2 arguments
local function modf_f64(x: float64, y: float64*): float64 <cimport'modf',nodecl,nosideeffect> end
local function modf_f32(x: float32, y: float32*): float32 <cimport'modff',nodecl,nosideeffect> end

-- define common math functions with 1 argument
##[[
local mathfuncs1 = {'abs','ceil','floor','sqrt','exp','acos','asin','cos','sin','tan'}
for _,name in ipairs(mathfuncs1) do
  local namef64, namef32 = name..'_f64', name..'_f32'
]]
function math.#|name|#(x: is_arithmetic) <inline,nosideeffect>
  ## if x.type.is_float32 then
    return #|namef32|#(x)
  ## elseif x.type.is_float then
    return #|namef64|#(x)
  ## else
    ## if name == 'abs' then
      if x < 0 then return -x else return x end
    ## elseif name == 'ceil' or name == 'floor' then
      return x
    ## else
      return #|namef64|#(x)
    ## end
  ## end
end
## end

-- define common math functions with 2 arguments
##[[
local mathfuncs2 = { 'max', 'min', 'fmod', 'pow' }
for _,name in ipairs(mathfuncs2) do
  local namef64, namef32 = name..'_f64', name..'_f32'
]]
function math.#|name|#(x: is_arithmetic, y: is_arithmetic) <inline,nosideeffect>
  ## if x.type.is_float32 then
    return #|namef32|#(x, y)
  ## elseif x.type.is_float then
    return #|namef64|#(x, y)
  ## else
    ## if name == 'min' then
      if x < y then return x else return y end
    ## elseif name == 'max' then
      if x < y then return y else return x end
    ## else
      return #|namef64|#(x, y)
    ## end
  ## end
end
## end

function math.atan(y: is_arithmetic, x: is_optional_arithmetic) <inline,nosideeffect>
  ## if not x.type.is_nil then
    ## if y.type.is_float32 and x.type.is_float32 then
      return atan2_f32(y, x)
    ## else
      return atan2_f64(y, x)
    ## end
  ## else
    ## if y.type.is_float32 then
      return atan_f32(y)
    ## else
      return atan_f64(y)
    ## end
  ## end
end

function math.log(x: is_arithmetic, base: is_optional_arithmetic) <inline,nosideeffect>
  ## local suffix = x.type.is_float32 and '_f32' or '_f64'
  ## local log2, log10, log = 'log2'..suffix, 'log10'..suffix, 'log'..suffix
  ## if not base.type.is_nil then
    if base == 2 then
      return #|log2|#(x)
    elseif base == 10 then
      return #|log10|#(x)
    else
      return #|log|#(x) / #|log|#(base)
    end
  ## else
    return #|log|#(x)
  ## end
end

function math.deg(x: is_arithmetic) <inline,nosideeffect>
  local R: type = #[choose_float_type(x)]#
  local factor: R <comptime> = 180.0 / math.pi
  return x * factor
end

function math.rad(x: is_arithmetic) <inline,nosideeffect>
  local R: type = #[choose_float_type(x)]#
  local factor: R <comptime> = math.pi / 180.0
  return x * factor
end

function math.modf(x: is_arithmetic) <inline,nosideeffect>
  local R: type = #[choose_float_type(x)]#
  local i: R
  local f: R <noinit>
  ## if x.type.is_float32 then
    f = modf_f32(x, &i)
  ## else
    f = modf_f64(x, &i)
  ## end
  return i, f
end

function math.tointeger(x: is_arithmetic) <inline,nosideeffect>
  ## if x.type.is_integral then
    return (@integer)(x)
  ## elseif x.type.is_float then
    local r = (@integer)(x)
    if likely(x == r) then
      return r
    else
      return nil
    end
  ## else
    return nil
  ## end
end

function math.type(x: is_arithmetic): stringview <inline,nosideeffect>
  ## if x.type.is_float then
    return 'float'
  ## elseif x.type.is_integral then
    return 'integer'
  ## else
    return nil
  ## end
end

function math.ult(m: is_arithmetic, n: is_arithmetic): boolean <inline>
  ## if m.type.is_integral and n.type.is_integral then
    return (@uinteger)(m) < (@uinteger)(n)
  ## elseif x.type.is_float then
    local mi, ni = (@integer)(m), (@integer)(n)
    if likely(mi == m and ni == n) then
      return (@uinteger)(mi) < (@uinteger)(ni)
    else
      panic('math.ult: m or n has no integer representation')
    end
  ## end
end

-- Pseudo Random Number Generator based on xoshiro256**
local xoshiro256 = @record{state: uint64[4]}

local function rotl(x: uint64, n: int32): uint64 <inline,nosideeffect>
  return (x << n) | (x >> (64 - n))
end

function xoshiro256:nextrand(): uint64
  local state: uint64[4] = {
    self.state[0],
    self.state[1],
    self.state[2] ~ self.state[0],
    self.state[3] ~ self.state[1]
  }
  local res: uint64 = rotl(state[1] * 5, 7) * 9
  self.state[0] = state[0] ~ state[3]
  self.state[1] = state[1] ~ state[2]
  self.state[2] = state[2] ~ (state[1] << 17)
  self.state[3] = rotl(state[3], 45)
  return res
end

function xoshiro256:random(): number
  ## local MANT_DIGITS = primtypes.number.is_float32 and 24 or 53
  local rv: uint64 = self:nextrand()
  return (rv >> (64 - #[MANT_DIGITS]#)) / (1_u64 << #[MANT_DIGITS]#)
end

function xoshiro256:seed(a: uint64, b: uint64)
  self.state[0] = a
  self.state[1] = 0xff
  self.state[2] = b
  self.state[3] = 0
  for i:integer=0,<16 do
    self:nextrand()
  end
end

-- pre initialize default random generator
local default_random: xoshiro256 = {state={
  0x65CE039BAEBE74B4, 0x4911ADA153B51EEF, 0xFB71FBB497C00950, 0xF83CCF6AC1B74755
}}

function math.randomseed(x: is_arithmetic) <inline>
  default_random:seed((@uint64)(x), 0)
end

function math.random(m: is_optional_arithmetic, n: is_optional_arithmetic) <inline>
  local r: number = default_random:random()
  ## if not m.type.is_nil and not n.type.is_nil then
    local low: integer, up: integer = (@integer)(m), (@integer)(n)
    if not likely(low <= up) then
      panic("random: interval is empty")
    elseif not likely(low >= 0 or up < math.maxinteger + low) then
      panic("random: interval too large")
    end
    r = r * ((@number)(up - low) + 1.0)
    return (@integer)(r) + low
  ## elseif not m.type.is_nil then
    local low: integer = (@integer)(m)
    r = r * (@number)(low)
    return (@integer)(r)
  ## else
    return r
  ## end
end
