## strict = true
## unitname = 'nelua'

global math = @record{}

-- constants
global math.pi: float64 <comptime> = 3.141592653589793
global math.huge: float64 <const,cimport'HUGE_VAL',cinclude'<math.h>',nodecl>
global math.maxinteger: integer <comptime> = 9223372036854775807
global math.mininteger: integer <comptime> = -9223372036854775808

-- compile time utilities
##[[
local function check_arithmetic(...)
  for i=1,select('#',...) do
    local x = select(i,...)
    staticassert(x.type:is_arithmetic(), "variable '%s' isn't an arithmetic type", x)
  end
end

local function choose_float_type(x)
  if x.type:is_float32() then
    return primtypes.float32
  else
    return primtypes.float64
  end
end
]]

-- import C math functions with 1 argument
##[[
local cmathfuncs1 = {'abs','ceil','floor','sqrt','exp','log','log2','log10','acos','asin','atan','cos','sin','tan'}
local cmathrenames1 = {abs='fabs'}
for _,name in ipairs(cmathfuncs1) do
  local cname = cmathrenames1[name] or name
  local cnamef64, cnamef32 = cname, cname..'f'
  local namef64, namef32 = name..'_f64', name..'_f32'
]]
  local function #(namef64)#(x: float64): float64
    <cimport#[cnamef64]#,cinclude'<math.h>',nodecl,nosideeffect>
  end
  local function #(namef32)#(x: float32): float32
    <cimport#[cnamef32]#,cinclude'<math.h>',nodecl,nosideeffect>
  end
## end

-- import C math functions with 2 arguments
##[[
local cmathfuncs2 = {'max','min','fmod','atan2','pow'}
local cmathrenames2 = {min='fmin',max='fmax'}
for _,name in ipairs(cmathfuncs2) do
  local cname = cmathrenames2[name] or name
  local cnamef64, cnamef32 = cname, cname..'f'
  local namef64, namef32 = name..'_f64', name..'_f32'
]]
  local function #(namef64)#(x: float64, y: float64): float64
    <cimport#[cnamef64]#,cinclude'<math.h>',nodecl,nosideeffect>
  end
  local function #(namef32)#(x: float32, y: float32): float32
    <cimport#[cnamef32]#,cinclude'<math.h>',nodecl,nosideeffect>
  end
## end

-- manually import special math functions with 2 arguments
local function modf_f64(x: float64, y: float64*): float64 <cimport'modf',nodecl,nosideeffect> end
local function modf_f32(x: float32, y: float32*): float32 <cimport'modff',nodecl,nosideeffect> end

-- define common math functions with 1 argument
##[[
local mathfuncs1 = {'abs','ceil','floor','sqrt','exp','acos','asin','cos','sin','tan'}
for _,name in ipairs(mathfuncs1) do
  local namef64, namef32 = name..'_f64', name..'_f32'
]]
function math.#(name)#(x: auto) <inline,nosideeffect>
  ## check_arithmetic(x)
  ## if x.type:is_float32() then
    return #(namef32)#(x)
  ## elseif x.type:is_float() then
    return #(namef64)#(x)
  ## else
    ## if name == 'abs' then
      if x < 0 then return -x else return x end
    ## elseif name == 'ceil' or name == 'floor' then
      return x
    ## else
      return #(namef64)#(x)
    ## end
  ## end
end
## end

-- define common math functions with 2 arguments
##[[
local mathfuncs2 = { 'max', 'min', 'fmod', 'pow' }
for _,name in ipairs(mathfuncs2) do
  local namef64, namef32 = name..'_f64', name..'_f32'
]]
function math.#(name)#(x: auto, y: auto) <inline,nosideeffect>
  ## check_arithmetic(x, y)
  ## if x.type:is_float32() then
    return #(namef32)#(x, y)
  ## elseif x.type:is_float() then
    return #(namef64)#(x, y)
  ## else
    ## if name == 'min' then
      if x < y then return x else return y end
    ## elseif name == 'max' then
      if x < y then return y else return x end
    ## else
      return #(namef64)#(x, y)
    ## end
  ## end
end
## end

function math.atan(y: auto, x: auto) <inline,nosideeffect>
  ## check_arithmetic(y)
  ## if not x.type:is_nil() then
    ## check_arithmetic(x)
    ## if y.type:is_float32() and x.type:is_float32() then
      return atan2_f32(y, x)
    ## else
      return atan2_f64(y, x)
    ## end
  ## else
    ## if y.type:is_float32() then
      return atan_f32(y)
    ## else
      return atan_f64(y)
    ## end
  ## end
end

function math.log(x: auto, base: auto) <inline,nosideeffect>
  ## check_arithmetic(x)
  ## local suffix = x.type:is_float32() and '_f32' or '_f64'
  ## local log2, log10, log = 'log2'..suffix, 'log10'..suffix, 'log'..suffix
  ## if not base.type:is_nil() then
    if base == 2 then
      return #(log2)#(x)
    elseif base == 10 then
      return #(log10)#(x)
    else
      return #(log)#(x) / #(log)#(base)
    end
  ## else
    return #(log)#(x)
  ## end
end

function math.deg(x: auto) <inline,nosideeffect>
  ## check_arithmetic(x)
  local R: type = #[choose_float_type(x)]#
  local factor: R <comptime> = 180 / math.pi
  return x * factor
end

function math.rad(x: auto) <inline,nosideeffect>
  ## check_arithmetic(x)
  local R: type = #[choose_float_type(x)]#
  local factor: R <comptime> = math.pi / 180.0
  return x * factor
end

function math.modf(x: auto) <inline,nosideeffect>
  ## check_arithmetic(x)
  local R: type = #[choose_float_type(x)]#
  local i: R
  local f: R <noinit>
  ## if x.type:is_float32() then
    f = modf_f32(x, &i)
  ## else
    f = modf_f64(x, &i)
  ## end
  return i, f
end

function math.tointeger(x: auto) <inline,nosideeffect>
  ## if x.type:is_integral() then
    return (@integer)(x)
  ## elseif x.type:is_float() then
    local r = (@integer)(x)
    if likely(x == r) then
      return r
    else
      return nil
    end
  ## else
    return nil
  ## end
end

function math.type(x: auto) <inline,nosideeffect>
  ## if x.type:is_float() then
    return 'float'
  ## elseif x.type:is_integral() then
    return 'integer'
  ## else
    return nil
  ## end
end

function math.ult(m: auto, n: auto): boolean <inline>
  ## check_arithmetic(m, n)
  ## if m.type:is_integral() and n.type:is_integral() then
    return (@uinteger)(m) < (@uinteger)(n)
  ## elseif x.type:is_float() then
    local mi, ni = (@integer)(m), (@integer)(n)
    if likely(mi == m and ni == n) then
      return (@uinteger)(mi) < (@uinteger)(ni)
    else
      panic('math.ult: m or n has no integer representation')
    end
  ## end
end

-- Pseudo Random Number Generator based on xoshiro256**
local xoshiro256 = @record{state: uint64[4]}

local function rotl(x: uint64, n: int32): uint64 <inline,nosideeffect>
  return (x << n) | (x >> (64 - n))
end

function xoshiro256:nextrand(): uint64
  local state: uint64[4] = {
    self.state[0],
    self.state[1],
    self.state[2] ~ self.state[0],
    self.state[3] ~ self.state[1]
  }
  local res: uint64 = rotl(state[1] * 5, 7) * 9
  self.state[0] = state[0] ~ state[3]
  self.state[1] = state[1] ~ state[2]
  self.state[2] = state[2] ~ (state[1] << 17)
  self.state[3] = rotl(state[3], 45)
  return res
end

function xoshiro256:random(): float64
  local FLOAT64_MANT_DIGS <comptime> = 53
  local rv: uint64 = self:nextrand()
  local v: uint64 = rv >> (64_i32 - FLOAT64_MANT_DIGS)
  return v / (1_uint64 << FLOAT64_MANT_DIGS)
end

function xoshiro256:seed(a: uint64, b: uint64)
  self.state[0] = a
  self.state[1] = 0xff
  self.state[2] = b
  self.state[3] = 0
  for i:integer=0,<16 do
    self:nextrand()
  end
end

-- pre initialize default random generator
local default_random: xoshiro256 = {state={
  0x65CE039BAEBE74B4, 0x4911ADA153B51EEF, 0xFB71FBB497C00950, 0xF83CCF6AC1B74755
}}

function math.randomseed(x: auto) <inline>
  ## check_arithmetic(x)
  default_random:seed((@uint64)(x), 0)
end

function math.random(m: auto, n: auto) <inline>
  local r: number = default_random:random()
  ## if not m.type:is_nil() and not n.type:is_nil() then
    ## check_arithmetic(m, n)
    local low: integer, up: integer = (@integer)(m), (@integer)(n)
    if not likely(low < up) then
      panic("random: interval is empty")
    elseif not likely(low >= 0 or up < math.maxinteger + low) then
      panic("random: interval too large")
    end
    r = r * ((@number)(up - low) + 1.0)
    return (@integer)(r) + low
  ## elseif not m.type:is_nil() then
    ## check_arithmetic(m)
    local low: integer = (@integer)(m)
    r = r * (@number)(low)
    return (@integer)(r)
  ## else
    return r
  ## end
end
