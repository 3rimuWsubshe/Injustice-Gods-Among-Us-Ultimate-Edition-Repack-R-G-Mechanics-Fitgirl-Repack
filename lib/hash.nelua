--[[
The hash library provides utilities to generate hash for values.

The included hash functions in this library are intended to be used containers such as `hashmap` and `table`,
thus the hash functions are designed to be fast, and are not necessarily equal across platforms
and may skip bytes.
Use a better hash algorithm in case you need deterministic hash across platforms
and with better quality.
]]

require 'span'

-- Namespace for hash module.
global hash: type = @record{}

local function frexp_f32(x: float32, exp: *cint): float32 <cimport'frexpf',cinclude'<math.h>',nodecl,nosideeffect> end
local function frexp_f64(x: float64, exp: *cint): float64 <cimport'frexp',cinclude'<math.h>',nodecl,nosideeffect> end

-- This is the same simple hash function used in Lua.
local function lhash(data: *[0]byte, len: usize, seed: usize, step: usize): usize <inline>
  seed = seed ~ len
  while len >= step do
    seed = seed ~ ((seed << 5) + (seed >> 2) + data[len - 1])
    len = len - step
  end
  return seed
end

--[[
Hashes a span of bytes, iterating over all bytes.
This function can be slow for long spans.
]]
function hash.short(data: span(byte)): usize <inline>
  return lhash(data.data, data.size, (@usize)(0x9e3779b9), 1)
end

--[[
Hashes a span of bytes, iterating at most 32 bytes evenly spaced.
This function can be fast to hash long spans, at cost of hash quality.
]]
function hash.long(data: span(byte)): usize <inline>
  return lhash(data.data, data.size, (@usize)(0x9e3779b9), (data.size >> 5) + 1)
end

-- Returns the combination of the hashes `seed` and `value`.
function hash.combine(seed: usize, value: usize): usize <inline>
  return seed ~ (value + (@usize)(0x9e3779b9) + (seed<<6) + (seed>>2))
end

--[[
Hashes value `v`, used to hash anything.

To customize a hash for a specific record you can define `__hash` metamethod,
and it will be used when calling this function.
]]
function hash.hash(v: auto): usize
  ## if v.type.is_pointer then
    -- usually pointers are multiple of 8, thus we can discard the last 3 bits
    return (@usize)(v) >> 3
  ## elseif v.type.is_integral then
    return (@usize)(v)
  ## elseif v.type.is_float then
    local ne: cint
    v = #|'frexp_f'..(v.type.is_float32 and '32' or '64')|#(v, &ne) * -(@float32)(#[primtypes.isize.min]#)
    if v ~= v or v == #[math.huge]# or v == -#[math.huge]# then -- non finite
      return 0
    end
    local u: usize = (@usize)(v) + (@usize)(ne)
    return u < (@usize)(#[primtypes.isize.max]#) and u or ~u
  ## elseif v.type.is_boolean then
    return v and 1 or 0
  ## elseif v.type.is_string then
    return hash.long({data=v.data, size=v.size})
  ## elseif v.type.is_span then
    local T: type = #[v.type.subtype]#
    return hash.long({data=(@*[0]byte)(v.data), size=(@usize)(#T * #v)})
  ## elseif v.type.is_record and v.type.metafields.__hash then
    return v:__hash()
  ## elseif v.type.is_record then
    local h: usize = 0
    ## for _,field in ipairs(v.type.fields) do -- hash all fields
      h = hash.combine(h, hash.hash(v.#|field.name|#))
    ## end
    return h
  ## elseif v.type.is_nilptr or v.type.is_niltype then
    return 0
  ## else static_error("cannot hash type '%s'", type) end
end
