-- String type
--
-- Strings points to an immutable contiguous sequence of characters.
-- It manages the memory on its own by allocating when needed and
-- deallocating when unused.
--
-- The string type and its methods are defined here,
-- currently it depends on the garbage collector to allocate
-- strings, in the future this may be improved by using
-- reference counted strings.
--
-- If you don't want to trigger the garbage collector
-- then does not use this module. Try to use just stringview
-- type or create your own string module.

-- These modules are used to implement the string.
require 'memory'
require 'stringview'
require 'stringbuilder'
require 'patternmatcher'
require 'sequence'
require 'allocators.default'

-- C imports.
local function strlen(s: cstring): csize <cimport,cinclude'<string.h>',nodecl> end
local function isdigit(x: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end
local function tolower(c: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end
local function toupper(c: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end
local function snprintf(s: cstring, maxlen: csize, format: cstring, ...: cvarargs): cint <cimport'snprintf',cinclude'<stdio.h>',nodecl> end

-- Define the string type.
global string <codename 'nlstring'> = @record{
  data: *[0]byte,
  size: usize
}

-- This sets some values to be used internally at compile time
-- to make the compiler known that this type represents a string.
##[[
local stringtype = symbols.string.value
stringtype.is_string = true
stringtype.is_stringy = true
stringtype.name = 'string'
]]

-- Allocate a new string to be filled. Used internally.
function string._create(size: usize): string
  local self: string
  check(size > 0, 'attempt to create an empty string')
  self.size = size
  self.data = (@*[0]byte)(default_allocator:xalloc(size+1))
  self.data[size] = 0
  return self
end

-- Destroys a string freeing its resources.
function string:destroy(): void <inline>
  default_allocator:dealloc(self.data)
  self.data = nilptr
  self.size = 0
end

function stringbuilder:promotestring(): string
  if unlikely(self.size == 0) then
    return (@string){}
  end
  local size: usize = self.size
  local data: span(byte) = self.allocator:spanxrealloc(self.data, size + 1) -- shrink
  data[size] = 0 -- cstring line ending
  $self = {} -- destroy
  return (@string){data = data.data, size = size}
end

function stringview.__tostring(s: stringview): string
  if unlikely(s.size == 0) then return (@string){} end
  local ret: string = string._create(s.size)
  memory.copy(&ret.data[0], s.data, s.size)
  return ret
end

function string.__tocstring(s: string): cstring <inline,nosideeffect>
  if unlikely(s.size == 0) then return (@cstring)('') end
  return (@cstring)(&s.data[0])
end

function string.__tostringview(s: string): stringview <inline,nosideeffect>
  if unlikely(s.size == 0) then return (@stringview){} end
  return (@stringview){data = &s.data[0], size = s.size}
end

function string.__convert(s: cstring): string
  if unlikely(not s) then return (@string){} end
  local size: usize = strlen(s)
  if unlikely(size == 0) then return (@string){} end
  local self: string = string._create(size)
  memory.copy(&self.data[0], s, size)
  return self
end

function string.sub(self: stringview, i: isize, j: facultative(isize)): string
  ## if j.type.is_niltype then
  local j: isize = -1
  ## end
  local size: isize = (@isize)(self.size)
  if unlikely(size == 0) then return self end
  if unlikely(i < 0) then i = size + i + 1 end
  if unlikely(i <= 0) then i = 1 end
  if unlikely(j < 0) then j = size + j + 1 end
  if unlikely(j > size) then j = size end
  if unlikely(i == 1 and j == size) then return self end
  if unlikely(i > j) then return (@string){} end
  local subsize: usize = (@usize)(j - i + 1)
  if unlikely(subsize == 0) then return (@string){} end
  local s: string = string._create(subsize)
  memory.copy(&s.data[0], &self.data[i-1], subsize)
  return s
end

function string.rep(self: stringview, n: isize, sep: facultative(stringview)): string
  if unlikely(n <= 0) then return (@string){} end
  if unlikely(n == 1) then return self end
  local n: usize = (@usize)(n)
  ## if sep.type.is_niltype then
  if unlikely(self.size == 0) then return (@string){} end
  local s: string = string._create(n * self.size)
  for i:usize=0,<n do
    memory.copy(&s.data[i*self.size], &self.data[0], self.size)
  end
  ## else
  local sep: stringview = sep
  local partsize: usize = self.size + sep.size
  if unlikely(partsize <= 0) then return (@string){} end
  local s: string = string._create(n * partsize - sep.size)
  for i:usize=0,<n do
    memory.copy(&s.data[i*partsize], &self.data[0], self.size)
    if i ~= n-1 then
      memory.copy(&s.data[i*partsize + self.size], &sep.data[0], sep.size)
    end
  end
  ## end
  return s
end

-- Looks for the first match of pattern in the string.
-- If it finds one, then returns true plus a sequence with the captured values,
-- otherwise it returns false plus an empty sequence.
-- If pattern specifies no captures, then the whole match is captured.
-- A third, optional argument specifies where to start the search, its default value is 1 and can be negative.
function string.match(self: stringview, pattern: stringview, init: facultative(isize)): (boolean, sequence(string))
  ## if init.type.is_niltype then
  local init: isize = 1
  ## end
  local ms: PatternMatcher = PatternMatcher.create(self, pattern)
  local s: isize, e: isize = ms:match(init, false)
  local captures: sequence(string)
  if e ~= -1 then
    if ms.numcaptures > 0 then -- has captures
      captures:resize((@usize)(ms.numcaptures))
      for i:isize=0,<ms.numcaptures do
        captures[(@usize)(i+1)] = ms:get_capture(i)
      end
      return true, captures
    else -- nothing captured, then capture whole match
      captures[1] = ms.source:sub(s+1, e)
      return true, captures
    end
  else -- no match
    return false, captures
  end
end

function string.reverse(self: stringview): string
  if unlikely(self.size == 0) then return self end
  local s: string = string._create(self.size)
  for i:usize=0,<self.size do
    s.data[i] = self.data[self.size - i - 1]
  end
  return s
end

function string.upper(self: stringview): string
  if unlikely(self.size == 0) then return self end
  local s: string = string._create(self.size)
  for i:usize=0,<self.size do
    s.data[i] = (@byte)(toupper(self.data[i]))
  end
  return s
end

function string.lower(self: stringview): string
  if unlikely(self.size == 0) then return self end
  local s: string = string._create(self.size)
  for i:usize=0,<self.size do
    s.data[i] = (@byte)(tolower(self.data[i]))
  end
  return s
end

function string.char(...: varargs): string
  local s: string = string._create(#[select_varargs('#')]#)
  ## for i=1,select_varargs('#') do
  s.data[#[i-1]#] = #[select_varargs(i)]#
  ## end
  return s
end

global function tostring(x: auto): string
  ## if x.type.is_stringy then
    -- use implicit conversion
    return x
  ## elseif x.type.is_arithmetic or x.type.is_function or x.type.is_pointer then
    ##[[
    local tyformat
    if x.type.is_function then
      tyformat = '"function: %p"'
    elseif x.type.is_pointer then
      tyformat = '"%p"'
    else
      tyformat = require'nelua.cdefs'.types_printf_format[x.type.codename]
    end
    static_assert(tyformat)
    ]]
    local fmt: cstring <cimport #[tyformat]#, nodecl, cinclude '<inttypes.h>'>
    local size: cint = snprintf(nilptr, 0, fmt, x)
    if unlikely(size <= 0) then return (@string){} end
    local s: string = string._create((@usize)(size))
    local dest: cstring = (@cstring)(&s.data[0])
    local n: csize = (@csize)(size+1)
    snprintf(dest, n, fmt, x)
    ## if x.type.is_float then
      -- add a least one decimal if needed
      local onlydigits: boolean = true
      for i:usize=0,<s.size do
        if not (isdigit(s.data[i]) ~= 0 or s.data[i] == '-'_byte) then
          onlydigits = false
          break
        end
      end
      if onlydigits then
        s = s..'.0'
      end
    ## end
    return s
  ## elseif x.type.is_boolean then
    if x == true then
      return 'true'
    end
    return 'false'
  ## elseif x.type.is_niltype then
    return 'nil'
  ## elseif x.type.is_polyfunction then
    return 'polyfunction'
  ## elseif x.type.is_record and x.type.metafields.__tostring then
    return x:__tostring()
  ## else static_error("tostring: cannot convert type '%s' to a string", x.type) end
end

function string.format(fmt: stringview, ...: varargs): string
  local sb: stringbuilder
  sb:write_format(fmt, ...)
  return sb:promotestring()
end

-- Concept to check if a value can possibly be a string.
local string_coercion_concept = #[concept(function(x)
  if x.type.is_stringy then
    return primtypes.stringview
  elseif x.type.is_integral then
    return primtypes.integer
  elseif x.type.is_float then
    return primtypes.number
  end
  return false, string.format("type '%s' is not convertible to a string", x.type)
end)]#

function string.__concat(a: string_coercion_concept, b: string_coercion_concept): string
  ## if not a.type.is_stringview then
  local a: string = tostring(a)
  ## end
  ## if not b.type.is_stringview then
  local b: string = tostring(b)
  ## end
  if a.size == 0 then
    return b
  elseif b.size == 0 then
    return a
  end
  local s: string = string._create(a.size + b.size)
  memory.copy(&s.data[0], a.data, a.size)
  memory.copy(&s.data[a.size], b.data, b.size)
  return s
end

-- Import methods from stringview to string.
##[[
local string_metafields = symbols.string.value.metafields
local stringview_metafields = symbols.stringview.value.metafields
string_metafields.__len = stringview_metafields.__len
string_metafields.__eq = stringview_metafields.__eq
string_metafields.__lt = stringview_metafields.__lt
string_metafields.__le = stringview_metafields.__le
string_metafields.__add = stringview_metafields.__add
string_metafields.__sub = stringview_metafields.__sub
string_metafields.__mul = stringview_metafields.__mul
string_metafields.__div = stringview_metafields.__div
string_metafields.__idiv = stringview_metafields.__idiv
string_metafields.__tdiv = stringview_metafields.__tdiv
string_metafields.__mod = stringview_metafields.__mod
string_metafields.__tmod = stringview_metafields.__tmod
string_metafields.__pow = stringview_metafields.__pow
string_metafields.__unm = stringview_metafields.__unm
string_metafields.__band = stringview_metafields.__band
string_metafields.__bor = stringview_metafields.__bor
string_metafields.__bxor = stringview_metafields.__bxor
string_metafields.__shl = stringview_metafields.__shl
string_metafields.__shr = stringview_metafields.__shr
string_metafields.__asr = stringview_metafields.__asr
string_metafields.__bnot = stringview_metafields.__bnot
string_metafields.len = stringview_metafields.len
string_metafields.byte = stringview_metafields.byte
string_metafields.find = stringview_metafields.find
string_metafields.subview = stringview_metafields.subview

-- Export string methods to stringview.
stringview_metafields.__concat = string_metafields.__concat
stringview_metafields.sub = string_metafields.sub
stringview_metafields.rep = string_metafields.rep
stringview_metafields.match = string_metafields.match
stringview_metafields.reverse = string_metafields.reverse
stringview_metafields.upper = string_metafields.upper
stringview_metafields.lower = string_metafields.lower
stringview_metafields.format = string_metafields.format
]]
