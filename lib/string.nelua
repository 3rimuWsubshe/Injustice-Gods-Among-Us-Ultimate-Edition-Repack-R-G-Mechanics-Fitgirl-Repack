require 'span'
require 'memory'
--require 'allocators.generic'

require 'allocators.gc'
local allocator = @gc_allocator

-- C imports
local errno: cint <cimport,cinclude'<errno.h>',nodecl>
local function strtoll(str: cstring, endptr: cstring*, base: cint): clonglong <cimport,cinclude'<stdlib.h>',nodecl> end
local function strtod(str: cstring, endptr: cstring*): float64 <cimport,cinclude'<stdlib.h>',nodecl> end
local function strspn(s: cstring, accept: cstring): csize <cimport,cinclude'<string.h>',nodecl> end
local function strchr(s: cstring, c: cint): cstring <cimport,cinclude'<string.h>',nodecl> end
local function strcpy(dest: cstring, src: cstring): cstring <cimport,cinclude'<string.h>',nodecl> end
local function strlen(s: cstring): csize <cimport,cinclude'<string.h>',nodecl> end
local function isalnum(x: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end
local function isdigit(x: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end
local function tolower(c: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end
local function toupper(c: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end

global string <codename 'nelua_string'> = @record{
  --refs: usize*,
  data: byte[0]*,
  size: usize
}

##[[
  local stringtype = context.rootscope.symbols.string.value
  stringtype.is_string = true
  stringtype.is_stringy = true
  stringtype.nick = 'string'
  stringtype.name = 'string'
  primtypes.stringview.metatype = types.MetaType()
  primtypes.stringview.metatype:inherit(stringtype.metatype)
]]

function string._create(size: usize): string <inline>
  local self: string
  check(size > 0, 'cannot create string with size 0')
  self.size = size
  self.data = (@byte[0]*)(allocator.alloc(size+1))
  self.data[size] = 0
  --self.refs = 1
  return self
end

function string:reset() <inline>
  $self = {}
end

function string.fromspan(s: span(byte)): string
  if unlikely(s.size == 0) then return (@string){} end
  local self = string._create(s.size)
  memory.copy(&self.data[0], s.data, s.size)
  return self
end

function string.fromcstring(s: cstring): string <inline>
  if unlikely(not s) then return (@string){} end
  local size: usize = strlen(s)
  if unlikely(size == 0) then return (@string){} end
  local self: string = string._create(size)
  memory.copy(&self.data[0], s, size)
  return self
end

--[[
function string:__copy(o: string*) <inline>
  self = o
  if likely(self) then
    self.refs = self.refs + 1
  end
end

function string:__destroy() <inline>
  if unlikely(self.size == 0) then return end
  self.refs = self.refs - 1
  if self.refs == 0 then
    allocator.dealloc(self)
    self = nilptr
  end
end
]]

local empty_cstring: cstring <const> = ''
function string.__tocstring(s: string): cstring <inline>
  if unlikely(s.size == 0) then return empty_cstring end
  return (@cstring)(&s.data[0])
end

function string.__tostringview(s: string): stringview <inline>
  if unlikely(s.size == 0) then return (@stringview){} end
  return (@stringview){data = &s.data[0], size = s.size}
end

function string.__convert(s: #[overload_concept({stringview,cstring},true)]#): string <inline>
  ## if s.type.is_stringview then
    return (@string){size=s.size, data=s.data}
  ## elseif s.type.is_cstring then
    return string.fromcstring(s)
  ## end
end

function stringview.__tostring(s: stringview) <inline>
  if unlikely(s.size == 0) then return (@string){} end
  local ret: string = string._create(s.size)
  memory.copy(&ret.data[0], s.data, s.size)
  return ret
end

function string.__len(a: stringview): isize <inline>
  return (@isize)(a.size)
end

function string.__eq(a: stringview, b: stringview): boolean
  return a.size == b.size and (a.size == 0 or memory.equals(a.data, b.data, a.size))
end

function string.__lt(a: stringview, b: stringview): boolean
  if unlikely(a.size == 0 or b.size == 0) then
    return a.size < b.size
  else
    if a.size < b.size then
      return memory.compare(a.data, b.data, a.size) <= 0
    else
      return memory.compare(a.data, b.data, b.size) < 0
    end
  end
end

function string.__le(a: stringview, b: stringview): boolean
  if unlikely(a.size == 0 or b.size == 0) then
    return a.size <= b.size
  else
    if a.size <= b.size then
      return memory.compare(a.data, b.data, a.size) <= 0
    else
      return memory.compare(a.data, b.data, b.size) < 0
    end
  end
end

function string.__concat(a: stringview, b: stringview): string
  if a.size == 0 then
    return b
  elseif b.size == 0 then
    return a
  end
  local s: string = string._create(a.size + b.size)
  memory.copy(&s.data[0], a.data, a.size)
  memory.copy(&s.data[a.size], b.data, b.size)
  return s
end

function string.len(self: stringview): isize <inline>
  return (@isize)(self.size)
end

function string.byte(self: stringview, i: #[optional_concept(isize)]#): byte
  -- TODO: j argument and multiple returns
  ## if i.type.is_niltype then
  local i: isize = 1
  ## end
  if unlikely(self.size == 0) then return 0 end
  if unlikely(i < 0) then
    i = self.size + i + 1
  end
  --TODO: return nil instead on failure
  check(i >= 1 and i <= self.size, 'string.byte: index out of range')
  return (@byte)(self.data[i-1])
end

function string.sub(self: stringview, i: isize, j: #[optional_concept(isize)]#): string
  ## if j.type.is_niltype then
  local j: isize = -1
  ## end
  if unlikely(self.size == 0) then return self end
  if unlikely(i < 0) then i = self.size + i + 1 end
  if unlikely(i <= 0) then i = 1 end
  if unlikely(j < 0) then j = self.size + j + 1 end
  if unlikely(j > self.size) then j = self.size end
  if unlikely(i == 1 and j == self.size) then return self end
  if unlikely(i > j) then return (@string){} end
  local size: usize = (@usize)(j - i + 1)
  if unlikely(size == 0) then return (@string){} end
  local s: string = string._create(size)
  memory.copy(&s.data[0], &self.data[i-1], size)
  return s
end

function string.rep(self: stringview, n: isize, sep: #[optional_concept(stringview)]#): string
  if unlikely(n <= 0) then return (@string){} end
  if unlikely(n == 1) then return self end
  ## if sep.type.is_niltype then
  if unlikely(self.size == 0) then return (@string){} end
  local s: string = string._create(n * self.size)
  for i:isize=0,<n do
    memory.copy(&s.data[i*self.size], &self.data[0], self.size)
  end
  ## else
  local sep: stringview = sep
  local partsize: usize = self.size + sep.size
  if unlikely(partsize <= 0) then return (@string){} end
  local s: string = string._create(n * partsize - sep.size)
  for i:isize=0,<n do
    memory.copy(&s.data[i*partsize], &self.data[0], self.size)
    if i ~= n-1 then
      memory.copy(&s.data[i*partsize + self.size], &sep.data[0], sep.size)
    end
  end
  ## end
  return s
end

function string.reverse(self: stringview): string
  if unlikely(self.size == 0) then return self end
  local s: string = string._create(self.size)
  for i:usize=0,<self.size do
    s.data[i] = self.data[self.size - i - 1]
  end
  return s
end

function string.upper(self: stringview): string
  if unlikely(self.size == 0) then return self end
  local s: string = string._create(self.size)
  for i:usize=0,<self.size do
    s.data[i] = (@byte)(toupper(self.data[i]))
  end
  return s
end

function string.lower(self: stringview): string
  if unlikely(self.size == 0) then return self end
  local s: string = string._create(self.size)
  for i:usize=0,<self.size do
    s.data[i] = (@byte)(tolower(self.data[i]))
  end
  return s
end

function string.char(c: byte): string
  --TODO: handle more arguments
  local s: string = string._create(1)
  s.data[0] = c
  return s
end

function string.find(self: stringview,
                     pattern: stringview,
                     init: isize,
                     plain: boolean): (isize, isize)
  --TODO: handle patterns and returns them
  --TODO: return nil if not found instead of zeros
  check(plain, 'string.find: patterns not supported yet')
  if unlikely(self.size == 0) then
    if pattern.size == 0 then return 1, 0 end
    return 0, 0
  end
  if unlikely(init < 0) then init = self.size + init + 1 end
  if unlikely(init > self.size) then return 0, 0 end
  if unlikely(init <= 0) then init = 1 end
  local found = memory.find(&self.data[init-1], self.size-init+1, pattern.data, pattern.size)
  if found then
    local sbegin: isize = (@isize)((@usize)(found) - (@usize)(&self.data[0]))
    return sbegin + 1, sbegin + (@isize)(pattern.size)
  end
  return 0, 0
end

-- TODO: implement functions bellow
-- string.format(fmt, ...)
-- string:match(pattern, init)
-- string:gmatch(pattern)
-- string:gsub(pattern, repl, n)
-- string.pack(fmt, v1, v2, ..)
-- string.unpack(fmt, s, pos)
-- string.packsize(fmt)

local is_arithmetic_convertible = #[concept(function(x)
  return x.type.is_stringy or x.type.is_arithmetic
end)]#

function string.__add(a: is_arithmetic_convertible, b: is_arithmetic_convertible): number
  return tonumber(a) + tonumber(b)
end

function string.__sub(a: is_arithmetic_convertible, b: is_arithmetic_convertible): number
  return tonumber(a) - tonumber(b)
end

function string.__mul(a: is_arithmetic_convertible, b: is_arithmetic_convertible): number
  return tonumber(a) * tonumber(b)
end

function string.__div(a: is_arithmetic_convertible, b: is_arithmetic_convertible): number
  return tonumber(a) / tonumber(b)
end

function string.__idiv(a: is_arithmetic_convertible, b: is_arithmetic_convertible): number
  return tonumber(a) // tonumber(b)
end

function string.__mod(a: is_arithmetic_convertible, b: is_arithmetic_convertible): number
  return tonumber(a) % tonumber(b)
end

function string.__pow(a: is_arithmetic_convertible, b: is_arithmetic_convertible): number
  return tonumber(a) ^ tonumber(b)
end

function string.__unm(a: is_arithmetic_convertible): number
  return -tonumber(a)
end

function string.__band(a: is_arithmetic_convertible, b: is_arithmetic_convertible): integer
  return tointeger(a) & tointeger(b)
end

function string.__bor(a: is_arithmetic_convertible, b: is_arithmetic_convertible): integer
  return tointeger(a) | tointeger(b)
end

function string.__bxor(a: is_arithmetic_convertible, b: is_arithmetic_convertible): integer
  return tointeger(a) ~ tointeger(b)
end

function string.__shl(a: is_arithmetic_convertible, b: is_arithmetic_convertible): integer
  return tointeger(a) << tointeger(b)
end

function string.__shr(a: is_arithmetic_convertible, b: is_arithmetic_convertible): integer
  return tointeger(a) >> tointeger(b)
end

function string.__bnot(a: is_arithmetic_convertible): integer
  return ~tointeger(a)
end

local function str2intbase(s: stringview, base: uinteger): integer
  assert(s.size > 0, "invalid number format")
  ## if base.type.is_niltype then
  local base: uinteger <const> = 10
  ## else
  check(base >= 2 and base <= 36, "base out of range")
  ## end
  local SPACECHARS: cstring <const> = " \f\n\r\t\v"
  local pos: usize = strspn(s, SPACECHARS) -- skip initial spaces
  local neg: boolean = false
  if s.data[pos] == #[string.byte'-']# then -- negative sign
    pos = pos + 1
    neg = true
  elseif s.data[pos] == #[string.byte'+']# then -- skip positive sign
    pos = pos + 1
  end
  local n: uinteger = 0
  repeat
    local digit: cint = s.data[pos]
    local x: cint
    if isdigit(digit) ~= 0 then -- is a digit [0-9]
      x = digit - #[string.byte'0']#
    elseif isalnum(digit) ~= 0 then -- is a alphanumeric [a-zA-Z]
      x = toupper(digit) - #[string.byte'A']# + 10
    else -- else spaces or invalid character
      break
    end
    assert(x < base, "invalid number format")
    n = n * base + (@uinteger)(x)
    pos = pos + 1
  until pos >= s.size
  pos = pos + strspn(&s.data[pos], SPACECHARS) -- skip trailing spaces
  check(pos == s.size, "invalid number format") -- fully parsed?
  if neg then -- negate
    n = -n
  end
  return (@integer)(n)
end

global function tonumber(x: auto, base: #[optional_concept(integer)]#)
  -- TODO: return nil in case of fail (like lua)
  ## if not base.type.is_niltype then
    ## staticassert(x.type.is_stringy, "string expected, got something else")
    return str2intbase(x, base)
  ## elseif x.type.is_arithmetic then
    return x
  ## elseif x.type.is_stringy then
    local x: cstring = x
    local endptr: cstring
    errno = 0
    local n: float64 = strtod(x, &endptr)
    check(endptr ~= x and errno == 0, 'failed to convert string to number')
    return (@number)(n)
  ## else
    ## staticerror("unable to convert value of type '%s' to a number", x.type)
  ## end
end

global function tointeger(x: auto, base: #[optional_concept(integer)]#): integer
  ## if not base.type.is_niltype then
    ## staticassert(x.type.is_stringy, "string expected, got something else")
    return str2intbase(x, base)
  ## elseif x.type.is_arithmetic then
    return (@integer)(x)
  ## elseif x.type.is_stringy then
    local x: cstring = x
    local endptr: cstring
    errno = 0
    local i: clonglong = strtoll(x, &endptr, 10)
    check(endptr ~= x and errno == 0, 'failed to convert string to integer')
    return (@integer)(i)
  ## else
    ## staticerror("unable to convert value of type '%s' to an integer", x.type)
  ## end
end

global function tostring(x: auto): string
  ## if x.type.is_arithmetic or x.type.is_function or x.type.is_pointer then
    local size: cint
    ##[[
    local tyformat
    if x.type.is_function then
      tyformat = '"function: %p"'
    else
      tyformat = require'nelua.cdefs'.types_printf_format[x.type.codename]
    end
    staticassert(tyformat)
    cinclude '<stdio.h>'
    cinclude '<inttypes.h>'
    cemit('size = snprintf(NULL, 0, '..tyformat..', x);')
    ]]
    if unlikely(size == 0) then return (@string){} end
    local s: string = string._create(size)
    local dest: cstring = (@cstring)(&s.data[0])
    local n: csize = (@csize)(size+1)
    ## cemit('snprintf(dest, n, '..tyformat..', x);')
    ## if x.type.is_float then
      -- add a least one decimal if needed
      local onlydigits: boolean = true
      for i=0,<s.size do
        if not (isdigit(s.data[i]) or s.data[i] == #[string.byte'-']#) then
          onlydigits = false
          break
        end
      end
      if onlydigits then
        s = s..'.0'
      end
    ## end
    return s
  ## elseif x.type.is_boolean then
    if x == true then
      return 'true'
    end
    return 'false'
  ## elseif x.type.is_stringy then
    return x
  ## elseif x.type.is_niltype then
    return 'nil'
  ## elseif x.type.is_lazyfunction then
    return 'lazyfunction'
  ## else
  ##   staticerror("tostring: cannot convert type '%s' to a string", x.type)
  ## end
end

-- Utility class used locally to compose strings
local stringbuffer = @record {
  size: usize,
  data: span(byte)
}

function stringbuffer.new(size: usize): stringbuffer
  return (@stringbuffer){
    size = 0,
    data = allocator.spanalloc(@byte, size)
  }
end

function stringbuffer:delete()
  allocator.spandealloc(self.data)
  $self = {}
end

function stringbuffer:prep(size: usize): cstring
  local needed: usize = self.size + size
  local cap: usize = self.data.size
  if unlikely(needed > cap) then
    repeat
      cap = cap * 2
    until cap >= needed
    self.data = allocator.spanrealloc(self.data, cap)
  end
  return (@cstring)(&self.data[self.size])
end

function stringbuffer:add(c: byte)
  if unlikely(self.size + 1 > self.data.size) then
    self.data = allocator.spanrealloc(self.data, self.size*2)
  end
  self.data[self.size] = c
  self.size = self.size + 1
end

function stringbuffer:addsize(size: usize)
  self.size = self.size + size
end

function stringbuffer:promotestring(): string
  if unlikely(self.size == 0) then
    self:delete()
    return (@string){}
  end
  local size: usize = self.size
  local data: span(byte) = allocator.spanrealloc(self.data, size + 1) -- shrink
  data[size] = 0 -- cstring line ending
  $self = {} -- destroy itself
  return (@string) {
    data = data.data,
    size = size
  }
end

-- Utilities for string.format
local function snprintf_1ci(s: cstring, maxlen: csize, format: cstring, x: cint): cint <cimport'snprintf',cinclude'<stdio.h>',nodecl> end
local function snprintf_1i(s: cstring, maxlen: csize, format: cstring, x: integer): cint <cimport'snprintf',cinclude'<stdio.h>',nodecl> end
local function snprintf_1p(s: cstring, maxlen: csize, format: cstring, x: pointer): cint <cimport'snprintf',cinclude'<stdio.h>',nodecl> end
local function snprintf_1n(s: cstring, maxlen: csize, format: cstring, x: number): cint <cimport'snprintf',cinclude'<stdio.h>',nodecl> end
local function snprintf_1cs(s: cstring, maxlen: csize, format: cstring, x: cstring): cint <cimport'snprintf',cinclude'<stdio.h>',nodecl> end

local MAX_FORMAT <comptime> = 32

local function scanformat(strfmt: byte[0]*, form: byte[MAX_FORMAT]*): usize
  local L_FMTFLAGS: stringview <const> = "-+ #0"
  local p: usize = 0
  while strfmt[p] ~= 0 and strchr(L_FMTFLAGS, strfmt[p]) ~= nilptr do
    p = p + 1  -- skip flags
  end
  if p >= (#L_FMTFLAGS + 1) // #@byte then
    error("invalid format (repeated flags)")
  end
  if isdigit(strfmt[p]) ~= 0 then p = p + 1 end  -- skip width
  if isdigit(strfmt[p]) ~= 0 then p = p + 1 end  -- (2 digits at most)
  if strfmt[p] == #[string.byte'.']# then
    p = p + 1
    if isdigit(strfmt[p]) ~= 0 then p = p + 1 end -- skip precision
    if isdigit(strfmt[p]) ~= 0 then p = p + 1 end -- (2 digits at most)
  end
  if isdigit(strfmt[p]) ~= 0 then
    error("invalid format (width or precision too long)")
  end
  form[0] = #[string.byte'%']#
  memory.copy(&form[1], &strfmt[p], (p + 1) * #@byte)
  form[p + 2] = 0
  return p
end

local function addlenmod(form: byte[MAX_FORMAT]*, lenmod: cstring, lenmodsize: csize)
  local l: csize = strlen(&form[0])
  local spec: byte = form[l - 1]
  strcpy(&form[l - 1], lenmod)
  form[l + lenmodsize - 1] = spec
  form[l + lenmodsize] = 0
end

function string.format(fmt: stringview, arg1: auto): string
  -- TODO: properly handle multiple arguments
  local L_ESC: byte <comptime> = #[string.byte'%']#
  local MAX_ITEM <comptime> = 120
  local pos: usize = 0
  local b: stringbuffer = stringbuffer.new(MAX_ITEM)
  local argi: integer = 0
  while pos < fmt.size do
    local c: byte = fmt.data[pos]
    pos = pos + 1
    if c ~= L_ESC then
      b:add(c)
    else
      c = fmt.data[pos]
      if c == L_ESC then -- %%
        b:add(L_ESC)
        pos = pos + 1
      else -- format item
        local form: byte[MAX_FORMAT] -- to store the format ('%...')
        local maxitem: usize = MAX_ITEM
        local buff: cstring = b:prep(MAX_ITEM) -- to put formatted item
        local nb: cint = 0 -- number of bytes in added item
        -- scan format
        pos = pos + scanformat(&fmt.data[pos], &form)
        c = fmt.data[pos]
        pos = pos + 1
        argi = argi + 1
        assert(argi == 1, 'format with multiple arguments not supported yet')
        ## if primtypes.cint:is_convertible_from(arg1.type) then
          if c == #[string.byte'c']# then
            local n: cint = (@cint)(arg1)
            nb = snprintf_1ci(buff, maxitem, &form[0], n)
            goto next
          end
        ## end
        ## if primtypes.integer:is_convertible_from(arg1.type) then
          if c == #[string.byte'd']# or
             c == #[string.byte'i']# or
             c == #[string.byte'o']# or
             c == #[string.byte'u']# or
             c == #[string.byte'x']# or
             c == #[string.byte'X']# then
            local lenmod: cstring <noinit>
            ## cemit('lenmod = PRIi' .. primtypes.integer.bitsize .. ';')
            addlenmod(&form, lenmod, strlen(lenmod) - 1)
            local n: integer = (@integer)(arg1)
            nb = snprintf_1i(buff, maxitem, &form[0], n)
            goto next
          end
        ## end
        ## if primtypes.number:is_convertible_from(arg1.type) then
          if c == #[string.byte'a']# or
             c == #[string.byte'A']# or
             c == #[string.byte'f']# or
             c == #[string.byte'e']# or
             c == #[string.byte'E']# or
             c == #[string.byte'g']# or
             c == #[string.byte'G']# then
            local n: number = (@number)(arg1)
            nb = snprintf_1n(buff, maxitem, &form[0], n)
            goto next
          end
        ## end
        ## if primtypes.pointer:is_convertible_from(arg1.type) then
          if c == #[string.byte'p']# then
            local p: pointer = (@pointer)(arg1)
            if p == nilptr then
              strcpy(buff, "(null)")
              nb = 6
            else
              nb = snprintf_1p(buff, maxitem, &form[0], p)
            end
            goto next
          end
        ## end
        ## if arg1.type.is_stringy then
          if c == #[string.byte's']# then
            local s: stringview = arg1
            maxitem = #s + 1
            buff = b:prep(maxitem)
            nb = snprintf_1cs(buff, maxitem, &form[0], arg1)
            goto next
          end
        ## end
        --TODO: 'q'
        local s: string = "invalid conversion '"..((@cstring)(&form[0]))..
                          "' for format argument #"..tostring(argi)
        error(s:__tostringview())
::next::
        assert(nb < maxitem)
        b:addsize(nb)
      end
    end
  end
  return b:promotestring()
end
