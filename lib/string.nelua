-- String methods
--
-- String points to an immutable contiguous sequence of characters.
-- Internally it just holds a pointer to a buffer and a size.
-- It's buffer is null terminated ('\0') by default to have more compatibility with C.
--
-- The string type is defined by the compiler, however it does not have
-- its methods implemented, this file implements all string methods.
--
-- Some methods may allocate a new string and you should call
-- `destroy` to free the string memory. Note that strings can point
-- to a buffer in the program static storage and such strings should never be destroyed.

-- Modules are used to implement string methods.
require 'memory'
require 'span'
require 'patternmatcher'
require 'sequence'
require 'allocators.default'

-- C imports.
local errno: cint <cimport,cinclude'<errno.h>',nodecl>
local function strtoll(str: cstring, endptr: *cstring, base: cint): clonglong <cimport,cinclude'<stdlib.h>',nodecl> end
local function strtod(str: cstring, endptr: *cstring): float64 <cimport,cinclude'<stdlib.h>',nodecl> end
local function snprintf(s: cstring, maxlen: csize, format: cstring, ...: cvarargs): cint <cimport'snprintf',cinclude'<stdio.h>',nodecl> end
local function isdigit(x: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end
local function isalnum(x: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end
local function isspace(x: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end
local function tolower(c: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end
local function toupper(c: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end

-- Allocate a new string to be filled. Used internally.
function string._create(size: usize): string
  local self: string
  check(size > 0, 'attempt to create an empty string')
  self.size = size
  self.data = (@*[0]byte)(default_allocator:xalloc(size+1))
  self.data[size] = 0
  return self
end

require 'stringbuilder' -- Must be required later because it depends on `string._create`

-- Destroys a string freeing its resources.
function string:destroy(): void
  ## if pragmas.nogc then -- cannot destroy when GC is enabled because string may be shared
  if self.size > 0 then
    default_allocator:dealloc(self.data)
    self.data = nilptr
    self.size = 0
  end
  ## end
end

-- Clone a string, allocating new space.
function string.copy(s: string): string
  local clone: string
  if unlikely(s.size == 0) then return clone end
  clone.data = (@*[0]byte)(default_allocator:xalloc(s.size+1))
  memory.copy(clone.data, s.data, s.size)
  clone.data[s.size] = 0
  clone.size = s.size
  return clone
end

-- Forward a string reference to be used elsewhere.
-- When GC is enabled this just returns the string itself.
-- When GC is disabled a string copy is returned, so it can be safely stored and destroyed.
function string._forward(s: string): string <inline>
  ## if pragmas.nogc then -- must return a clone so we can destroy it later
  return string.copy(s)
  ## else -- reuse the string reference when GC is enabled
  return s
  ## end
end

-- Returns the internal numeric codes of the character at position `i`.
function string.byte(self: string, i: facultative(isize)): byte
  -- TODO: j argument and multiple returns
  ## if i.type.is_niltype then
  local i: isize = 1
  ## end
  if unlikely(self.size == 0) then return 0 end
  if unlikely(i < 0) then i = self.size + i + 1 end
  --TODO: return nil instead on failure
  check(i >= 1 and (@usize)(i) <= self.size, 'index out of range')
  return (@byte)(self.data[i-1])
end

-- Return a view for sub string for a string.
-- The main difference between this and `string.sub` is that, here we don't allocate a new string,
-- instead it reuses its memory as an optimization.
-- Use this only if you know what you are doing, to be safe use `string.sub` instead.
-- WARNING1: When using the GC the view will not hold reference of the original string allocated at
-- runtime and the data may be collected.
-- WARNING2: The view string will may not be null terminated, thus you should never
-- convert it to a cstring and use in C functions.
function string.subview(self: string, i: isize, j: facultative(isize)): string
  ## if j.type.is_niltype then
  local j: isize = -1
  ## end
  local size: isize = (@isize)(self.size)
  if unlikely(size == 0) then return (@string){} end
  if unlikely(i < 0) then i = size + i + 1 end
  if unlikely(i <= 0) then i = 1 end
  if unlikely(j < 0) then j = size + j + 1 end
  if unlikely(j > size) then j = size end
  if unlikely(i == 1 and j == size) then return self end
  if unlikely(i > j) then return (@string){} end
  local subsize: usize = (@usize)(j - i + 1)
  if unlikely(subsize == 0) then return (@string){} end
  return (@string){data=&self.data[i-1], size=subsize}
end

-- Looks for the first match of pattern in the string.
-- Returns the indices of where this occurrence starts and ends.
-- The indices will be positive if a match is found, zero otherwise.
-- A third, optional argument specifies where to start the search, its default value is 1 and can be negative.
-- A value of true as a fourth, optional argument plain turns off the pattern matching facilities.
function string.find(self: string, pattern: string, init: facultative(isize), plain: facultative(boolean)): (isize, isize)
  ## if init.type.is_niltype then
  local init: isize = 1
  ## end
  ## if plain.type.is_niltype then
  local plain: boolean = false
  ## end
  local ms: PatternMatcher = PatternMatcher.create(self, pattern)
  local s: isize, e: isize = ms:match(init, plain)
  if e ~= -1 then
    return s+1, e
  else -- no match
    return 0, 0
  end
end

-- Returns an iterator function that, each time it is called, returns the whole match plus a span of captures.
-- A third, optional argument specifies where to start the search, its default value is 1 and can be negative.
function string.gmatch(s: string, pattern: string, init: facultative(isize))
  ## if init.type.is_niltype then
  local init: isize = 1
  ## end
  local MAX_CAPTURES <comptime> = 8
  local GMatchState: type = @record{
    ms: PatternMatcher,
    init: isize,
    captures: [MAX_CAPTURES]string
  }
  local function gmatch_next(state: *GMatchState, it: string): (boolean, string, span(string))
    local ok: boolean, matched: string, captures: span(string)
    local s: isize, e: isize = state.ms:match(state.init, false)
    if e ~= -1 then -- no match
      ok = true
      state.init = e+1
      matched = (@string){data=&state.ms.source.data[s], size=(@usize)(e-s)}
      assert(state.ms.numcaptures <= MAX_CAPTURES, 'too many captures')
      for i:isize=0,<state.ms.numcaptures do
        state.captures[i] = state.ms:get_capture(i)
      end
      captures = (@span(string)){data=&state.captures[0], size=(@usize)(state.ms.numcaptures)}
    end
    return ok, matched, captures
  end
  local state: GMatchState = {ms = PatternMatcher.create(s, pattern), init = init}
  return gmatch_next, state, (@string){}
end

function string.sub(self: string, i: isize, j: facultative(isize)): string
  ## if j.type.is_niltype then
  local j: isize = -1
  ## end
  local size: isize = (@isize)(self.size)
  if unlikely(size == 0) then return (@string){} end
  if unlikely(i < 0) then i = size + i + 1 end
  if unlikely(i <= 0) then i = 1 end
  if unlikely(j < 0) then j = size + j + 1 end
  if unlikely(j > size) then j = size end
  if unlikely(i == 1 and j == size) then return string._forward(self) end
  if unlikely(i > j) then return (@string){} end
  local subsize: usize = (@usize)(j - i + 1)
  if unlikely(subsize == 0) then return (@string){} end
  local s: string = string._create(subsize)
  memory.copy(&s.data[0], &self.data[i-1], subsize)
  return s
end

function string.rep(self: string, n: isize, sep: facultative(string)): string
  if unlikely(n <= 0) then return (@string){} end
  if unlikely(n == 1) then return string._forward(self) end
  local n: usize = (@usize)(n)
  ## if sep.type.is_niltype then
  if unlikely(self.size == 0) then return (@string){} end
  local s: string = string._create(n * self.size)
  for i:usize=0,<n do
    memory.copy(&s.data[i*self.size], &self.data[0], self.size)
  end
  ## else
  local sep: string = sep
  local partsize: usize = self.size + sep.size
  if unlikely(partsize <= 0) then return (@string){} end
  local s: string = string._create(n * partsize - sep.size)
  for i:usize=0,<n do
    memory.copy(&s.data[i*partsize], &self.data[0], self.size)
    if i ~= n-1 then
      memory.copy(&s.data[i*partsize + self.size], &sep.data[0], sep.size)
    end
  end
  ## end
  return s
end

-- Looks for the first match of pattern in the string.
-- If it finds one, then returns true plus a sequence with the captured values,
-- otherwise it returns false plus an empty sequence.
-- If pattern specifies no captures, then the whole match is captured.
-- A third, optional argument specifies where to start the search, its default value is 1 and can be negative.
function string.match(self: string, pattern: string, init: facultative(isize)): (boolean, sequence(string))
  ## if init.type.is_niltype then
  local init: isize = 1
  ## end
  local ms: PatternMatcher = PatternMatcher.create(self, pattern)
  local s: isize, e: isize = ms:match(init, false)
  local captures: sequence(string)
  if e ~= -1 then
    if ms.numcaptures > 0 then -- has captures
      captures:resize((@usize)(ms.numcaptures))
      for i:isize=0,<ms.numcaptures do
        captures[(@usize)(i+1)] = ms:get_capture(i)
      end
      return true, captures
    else -- nothing captured, then capture whole match
      captures[1] = ms.source:subview(s+1, e)
      return true, captures
    end
  else -- no match
    return false, captures
  end
end

function string.reverse(self: string): string
  if unlikely(self.size == 0) then return self end
  local s: string = string._create(self.size)
  for i:usize=0,<self.size do
    s.data[i] = self.data[self.size - i - 1]
  end
  return s
end

function string.upper(self: string): string
  if unlikely(self.size == 0) then return self end
  local s: string = string._create(self.size)
  for i:usize=0,<self.size do
    s.data[i] = (@byte)(toupper(self.data[i]))
  end
  return s
end

function string.lower(self: string): string
  if unlikely(self.size == 0) then return self end
  local s: string = string._create(self.size)
  for i:usize=0,<self.size do
    s.data[i] = (@byte)(tolower(self.data[i]))
  end
  return s
end

function string.char(...: varargs): string
  local s: string = string._create(#[select_varargs('#')]#)
  ## for i=1,select_varargs('#') do
  s.data[#[i-1]#] = #[select_varargs(i)]#
  ## end
  return s
end

function string.format(fmt: string, ...: varargs): string
  local sb: stringbuilder
  sb:write_format(fmt, ...)
  return sb:promote()
end

-- Return length of a string.
function string.len(self: string): isize <inline>
  return (@isize)(self.size)
end

-- Concept to check if a value can possibly be a number.
local scalar_coercion_concept = #[concept(function(x)
  if x.type.is_stringy then
    return primtypes.string
  elseif x.type.is_integral then
    return primtypes.integer
  elseif x.type.is_float then
    return primtypes.number
  end
  return false, string.format("type '%s' is not convertible to a scalar", x.type)
end)]#

-- Return length of a string.
function string.__len(a: string): isize <inline>
  return (@isize)(a.size)
end

-- Compare two strings.
function string.__eq(a: string, b: string): boolean
  return a.size == b.size and (a.data == b.data or a.size == 0 or memory.equals(a.data, b.data, a.size))
end

-- Compare if string `a` is less than string `b` in lexicographical order.
function string.__lt(a: string, b: string): boolean
  if unlikely(a.size == 0 or b.size == 0) then
    return a.size < b.size
  else
    if a.size < b.size then
      return memory.compare(a.data, b.data, a.size) <= 0
    else
      return memory.compare(a.data, b.data, b.size) < 0
    end
  end
end

-- Compare if string `a` is less or equal than string `b` in lexicographical order.
function string.__le(a: string, b: string): boolean
  if unlikely(a.size == 0 or b.size == 0) then
    return a.size <= b.size
  else
    if a.size <= b.size then
      return memory.compare(a.data, b.data, a.size) <= 0
    else
      return memory.compare(a.data, b.data, b.size) < 0
    end
  end
end

-- Implement numeric operators for string.
function string.__add(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  return tonumber(a) + tonumber(b)
end

function string.__sub(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  return tonumber(a) - tonumber(b)
end

function string.__mul(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  return tonumber(a) * tonumber(b)
end

function string.__div(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  return tonumber(a) / tonumber(b)
end

function string.__idiv(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  return tonumber(a) // tonumber(b)
end

function string.__tdiv(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  return tonumber(a) /// tonumber(b)
end

function string.__mod(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  return tonumber(a) % tonumber(b)
end

function string.__tmod(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  return tonumber(a) %%% tonumber(b)
end

function string.__pow(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  return tonumber(a) ^ tonumber(b)
end

function string.__unm(a: scalar_coercion_concept): number
  return -tonumber(a)
end

function string.__band(a: scalar_coercion_concept, b: scalar_coercion_concept): integer
  return tointeger(a) & tointeger(b)
end

function string.__bor(a: scalar_coercion_concept, b: scalar_coercion_concept): integer
  return tointeger(a) | tointeger(b)
end

function string.__bxor(a: scalar_coercion_concept, b: scalar_coercion_concept): integer
  return tointeger(a) ~ tointeger(b)
end

function string.__shl(a: scalar_coercion_concept, b: scalar_coercion_concept): integer
  return tointeger(a) << tointeger(b)
end

function string.__shr(a: scalar_coercion_concept, b: scalar_coercion_concept): integer
  return tointeger(a) >> tointeger(b)
end

function string.__asr(a: scalar_coercion_concept, b: scalar_coercion_concept): integer
  return tointeger(a) >>> tointeger(b)
end

function string.__bnot(a: scalar_coercion_concept): integer
  return ~tointeger(a)
end

-- Concept to check if a value can possibly be a string.
local string_coercion_concept = #[concept(function(x)
  if x.type.is_stringy then
    return primtypes.string
  elseif x.type.is_integral then
    return primtypes.integer
  elseif x.type.is_float then
    return primtypes.number
  end
  return false, string.format("type '%s' is not convertible to a string", x.type)
end)]#

function string.__concat(a: string_coercion_concept, b: string_coercion_concept): string
  ## if not a.type.is_string then
    local a: string = tostring(a)
    defer a:destroy() end
  ## end
  ## if not b.type.is_string then
    local b: string = tostring(b)
    defer b:destroy() end
  ## end
  if a.size == 0 then
    return string._forward(b)
  elseif b.size == 0 then
    return string._forward(a)
  end
  local s: string = string._create(a.size + b.size)
  memory.copy(&s.data[0], a.data, a.size)
  memory.copy(&s.data[a.size], b.data, b.size)
  return s
end

-- Convert a string to an integer in the desired base.
local function str2intbase(s: string, base: uinteger): integer
  assert(s.size > 0, "invalid number format")
  ## if base.type.is_niltype then
  local base: uinteger <const> = 10
  ## else
  assert(base >= 2 and base <= 36, "base out of range")
  ## end
  local pos: usize = 0
  while pos < s.size and isspace(s.data[pos]) ~= 0 do pos = pos + 1 end -- skip initial spaces
  assert(pos < s.size, "invalid number format")
  local neg: boolean = false
  if s.data[pos] == '-'_byte then -- negative sign
    pos = pos + 1
    neg = true
  elseif s.data[pos] == '+'_byte then -- skip positive sign
    pos = pos + 1
  end
  local n: uinteger = 0
  while pos < s.size do
    local digit: cint = s.data[pos]
    local x: cint
    if isdigit(digit) ~= 0 then -- is a digit [0-9]
      x = digit - '0'_byte
    elseif isalnum(digit) ~= 0 then -- is a alphanumeric [a-zA-Z]
      x = toupper(digit) - 'A'_byte + 10
    else -- else spaces or invalid character
      break
    end
    assert(x < (@cint)(base), "invalid number format")
    n = n * base + (@uinteger)(x)
    pos = pos + 1
  end
  while pos < s.size and isspace(s.data[pos]) ~= 0 do pos = pos + 1 end -- skip trailing spaces
  assert(pos == s.size, "invalid number format") -- fully parsed?
  if neg then -- negate
    n = -n
  end
  return (@integer)(n)
end


-- Convert a string to a cstring using a temporary buffer,
-- this is mainly used to ensure the string is null terminated ('\0').
global function tocstring(buf: *[0]cchar, buflen: usize, s: string): boolean
  if buflen >= s.size + 1 then
    memory.copy(buf, &s.data[0], s.size)
    buf[s.size] = 0
    return true
  end
  return false
end

-- Convert a value to a number.
global function tonumber(x: auto, base: facultative(integer))
  -- TODO: return nil in case of fail (like lua)
  ## if not base.type.is_niltype then
    ## static_assert(x.type.is_stringy, "string expected, got something else")
    return str2intbase(x, base)
  ## elseif x.type.is_integral then
    local n: integer = x
    return n
  ## elseif x.type.is_float then
    local n: number = x
    return n
  ## elseif x.type.is_stringy then
    local endptr: cstring
    local tmpbuf: [65]cchar
    assert(tocstring(&tmpbuf, #tmpbuf, x)) -- ensure it's null terminated
    errno = 0
    local n: float64 = strtod(&tmpbuf, &endptr)
    local len: usize = (@usize)(endptr) - (@usize)(&tmpbuf)
    assert(len > 0 and len <= #x and errno == 0, 'failed to convert string to number')
    return (@number)(n)
  ## else static_error("unable to convert value of type '%s' to a number", x.type) end
end

-- Convert a value to an integer.
global function tointeger(x: auto, base: facultative(integer)): integer
  ## if not base.type.is_niltype then
    ## static_assert(x.type.is_stringy, "string expected, got something else")
    return str2intbase(x, base)
  ## elseif x.type.is_scalar then
    local n: integer = x
    return n
  ## elseif x.type.is_stringy then
    local endptr: cstring
    local tmpbuf: [65]cchar
    assert(tocstring(&tmpbuf, #tmpbuf, x)) -- ensure it's null terminated
    errno = 0
    local i: clonglong = strtoll(&tmpbuf, &endptr, 10)
    local len: usize = (@usize)(endptr) - (@usize)(&tmpbuf)
    assert(len > 0 and len <= #x and errno == 0, 'failed to convert string to integer')
    return i
  ## else static_error("unable to convert value of type '%s' to an integer", x.type) end
end

global function tostring(x: auto): string
  ## local xobjtype = x.type:implicit_deref_type()
  ## if x.type.is_stringy then
    return string._forward(x)
  ## elseif xobjtype.is_record and xobjtype.metafields.__tostring then
    return x:__tostring()
  ## elseif x.type.is_scalar or x.type.is_function or x.type.is_pointer then
    ## if x.type.is_pointer then tyformat = '"0x%" PRIxPTR'
    local x: usize = (@usize)(x)
    if x == 0 then
      return string._forward('(null)')
    end
    ## elseif x.type.is_function then tyformat = '"function: 0x%" PRIxPTR'
    local x: usize = (@usize)((@pointer)(x))
    if x == 0 then
      return string._forward('function: (null)')
    end
    ##[[ else
      tyformat = require'nelua.cdefs'.types_printf_format[x.type.codename]
      static_assert(tyformat)
    end]]
    local fmt: cstring <cimport #[tyformat]#, nodecl, cinclude '<inttypes.h>'>
    local size: cint = snprintf(nilptr, 0, fmt, x)
    if unlikely(size <= 0) then return (@string){} end
    local s: string = string._create((@usize)(size))
    local dest: cstring = (@cstring)(&s.data[0])
    local n: csize = (@csize)(size+1)
    snprintf(dest, n, fmt, x)
    ## if x.type.is_float then
      -- add a least one decimal if needed
      local onlydigits: boolean = true
      for i:usize=0,<s.size do
        if not (isdigit(s.data[i]) ~= 0 or s.data[i] == '-'_byte) then
          onlydigits = false
          break
        end
      end
      if onlydigits then -- append '.0' to the string
        s.data = (@*[0]byte)(default_allocator:xrealloc(s.data, s.size+3, s.size+1))
        s.data[s.size] = '.'_byte
        s.data[s.size+1] = '0'_byte
        s.data[s.size+2] = 0
        s.size = s.size + 2
      end
    ## end
    return s
  ## elseif x.type.is_boolean then
    if x == true then
      return string._forward('true')
    end
    return string._forward('false')
  ## elseif x.type.is_niltype then
    return string._forward('nil')
  ## elseif x.type.is_nilptr then
    return string._forward('(null)')
  ## elseif x.type.is_polyfunction then
    return string._forward('polyfunction')
  ## else static_error("tostring: cannot convert type '%s' to a string", x.type) end
end
