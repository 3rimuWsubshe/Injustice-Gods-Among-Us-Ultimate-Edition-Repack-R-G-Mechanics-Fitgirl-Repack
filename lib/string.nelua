--[[
The string library provides functions to manipulate strings.

String points to an immutable contiguous sequence of characters.
Internally it just holds a pointer to a buffer and a size.
It's buffer is zero terminated by default to have more compatibility with C.

The string type is defined by the compiler, however it does not have
its methods implemented, this module implements all string methods.

When the GC is disabled, you should call `string.destroy` to free the string memory
of non views strings returned by this library, otherwise the memory will leak.
Note that string literals points to a buffer in the program static storage
and such strings should never be destroyed.

Note that all string methods are 1-indexed (like Lua).
]]

require 'memory'
require 'span'
require 'sequence'
require 'stringbuilder'
require 'allocators.default'
require 'detail.patternmatcher'

--[[
Allocate a new string to be filled with length `size`.

The string is guaranteed to be zero terminated,
so it can safely be used as a `cstring`.
The string data is not initialized.
]]
function string.create(size: usize): string
  check(size > 0, 'attempt to create an empty string')
  local s: string = {
    data = (@*[0]byte)(default_allocator:xalloc(size+1)),
    size = size,
  }
  s.data[size] = 0
  return s
end

--[[
Destroys a string freeing its memory.

This must never be called on string literals.
This function is only needed to be called when not using the GC.
]]
function string:destroy(): void
  if unlikely(self.size == 0) then return end
  default_allocator:dealloc(self.data)
  self.data = nilptr
  self.size = 0
end

-- Effectively the same as `destroy`, called when a to-be-closed variable goes out of scope.
function string:__close(): void
  self:destroy()
end

--[[
Clone a string, allocating new space.

This is useful in case you want to own the string memory,
so you can modify it or manually manage its memory when GC is disabled.
]]
function string.copy(s: string): string
  local clone: string
  if unlikely(s.size == 0) then return clone end
  clone.data = (@*[0]byte)(default_allocator:xalloc(s.size+1))
  memory.copy(clone.data, s.data, s.size)
  clone.data[s.size] = 0
  clone.size = s.size
  return clone
end

-- Returns the internal numeric codes of the character at position `i`.
function string.byte(s: string, i: facultative(isize)): byte
  ## if i.type.is_niltype then
  local i: isize = 1
  ## end
  -- TODO: j argument and multiple returns
  if unlikely(s.size == 0) then return 0 end
  if unlikely(i < 0) then i = s.size + i + 1 end
  --TODO: return nil instead on failure
  check(i >= 1 and (@usize)(i) <= s.size, 'index out of range')
  return s.data[i-1]
end

--[[
Returns the substring of `s` that starts at `i` and continues until `j` (both inclusive).
Both `i` and `j` can be negative.
If `j` is absent, then it is assumed to be equal to `-1` (which is the same as the string length).
In particular, the call `string.sub(s,1,j)` returns a prefix of `s` with length `j`,
and `string.sub(s, -i)` (for a positive `i`) returns a suffix of `s` with length `i`.
]]
function string.sub(s: string, i: isize, j: facultative(isize)): string
  ## if j.type.is_niltype then
  local j: isize = -1
  ## end
  local size: isize = (@isize)(s.size)
  if unlikely(size == 0) then return (@string){} end
  if unlikely(i < 0) then i = size + i + 1 end
  if unlikely(i <= 0) then i = 1 end
  if unlikely(j < 0) then j = size + j + 1 end
  if unlikely(j > size) then j = size end
  if unlikely(i == 1 and j == size) then return string.copy(s) end
  if unlikely(i > j) then return (@string){} end
  local subsize: usize = (@usize)(j - i + 1)
  if unlikely(subsize == 0) then return (@string){} end
  local ret: string = string.create(subsize)
  memory.copy(&ret.data[0], &s.data[i-1], subsize)
  return ret
end

--[[
Return a view for a sub string in a string.

The main difference between this and `string.sub` is that here we don't allocate a new string,
instead it reuses its memory as an optimization.
Use this only if you know what you are doing, to be safe use `string.sub` instead.

*Remarks*: When using the GC the view will not hold reference to the original string,
thus if you don't hold the original string reference somewhere you will have a dangling reference.
The view string may not be zero terminated, thus you should never
cast it to a `cstring` to use in C functions.
]]
function string.subview(s: string, i: isize, j: facultative(isize)): string
  ## if j.type.is_niltype then
  local j: isize = -1
  ## end
  local size: isize = (@isize)(s.size)
  if unlikely(size == 0) then return (@string){} end
  if unlikely(i < 0) then i = size + i + 1 end
  if unlikely(i <= 0) then i = 1 end
  if unlikely(j < 0) then j = size + j + 1 end
  if unlikely(j > size) then j = size end
  if unlikely(i == 1 and j == size) then return s end
  if unlikely(i > j) then return (@string){} end
  local subsize: usize = (@usize)(j - i + 1)
  if unlikely(subsize == 0) then return (@string){} end
  return (@string){data=&s.data[i-1], size=subsize}
end

--[[
Look for the first match of pattern in the string.

Returns the indices of where this occurrence starts and ends.

The indices will be positive if a match is found, zero otherwise.
A third, optional argument specifies where to start the search, its default value is 1 and can be negative.
A value of true as a fourth, optional argument plain turns off the pattern matching facilities.
]]
function string.find(s: string, pattern: string, init: facultative(isize), plain: facultative(boolean)): (isize, isize)
  ## if init.type.is_niltype then
  local init: isize = 1
  ## end
  ## if plain.type.is_niltype then
  local plain: boolean = false
  ## end
  local ms: PatternMatcher = PatternMatcher.create(s, pattern)
  local startpos: isize, endpos: isize = ms:match(init, plain)
  if endpos ~= -1 then
    return startpos+1, endpos
  else -- no match
    return 0, 0
  end
end

--[[
Returns an iterator function that, each time it is called, returns the whole match plus a span of captures.
A third, optional argument specifies where to start the search, its default value is 1 and can be negative.
]]
function string.gmatch(s: string, pattern: string, init: facultative(isize)): (auto, auto, string)
  ## if init.type.is_niltype then
  local init: isize = 1
  ## end
  local MAX_CAPTURES <comptime> = 8
  local GMatchState: type = @record{
    ms: PatternMatcher,
    init: isize,
    captures: [MAX_CAPTURES]string
  }
  local function gmatch_next(state: *GMatchState, it: string): (boolean, string, span(string))
    local ok: boolean, matched: string, captures: span(string)
    local s: isize, e: isize = state.ms:match(state.init, false)
    if e ~= -1 then -- no match
      ok = true
      state.init = e+2
      matched = string.copy((@string){data=&state.ms.source.data[s], size=(@usize)(e-s)})
      assert(state.ms.numcaptures <= MAX_CAPTURES, 'too many captures')
      for i:isize=0,<state.ms.numcaptures do
        state.captures[i] = string.copy(state.ms:get_capture(i))
      end
      captures = (@span(string)){data=&state.captures[0], size=(@usize)(state.ms.numcaptures)}
    end
    return ok, matched, captures
  end
  local state: GMatchState = {ms = PatternMatcher.create(s, pattern), init = init}
  return gmatch_next, state, (@string){}
end

-- Like `string.gmatch` but uses sub string views (see also `string.subview`).
function string.gmatchview(s: string, pattern: string, init: facultative(isize)): (auto, auto, string)
  ## if init.type.is_niltype then
  local init: isize = 1
  ## end
  local MAX_CAPTURES <comptime> = 8
  local GMatchState: type = @record{
    ms: PatternMatcher,
    init: isize,
    captures: [MAX_CAPTURES]string
  }
  local function gmatch_next(state: *GMatchState, it: string): (boolean, string, span(string))
    local ok: boolean, matched: string, captures: span(string)
    local s: isize, e: isize = state.ms:match(state.init, false)
    if e ~= -1 then -- no match
      ok = true
      state.init = e+2
      matched = (@string){data=&state.ms.source.data[s], size=(@usize)(e-s)}
      assert(state.ms.numcaptures <= MAX_CAPTURES, 'too many captures')
      for i:isize=0,<state.ms.numcaptures do
        state.captures[i] = state.ms:get_capture(i)
      end
      captures = (@span(string)){data=&state.captures[0], size=(@usize)(state.ms.numcaptures)}
    end
    return ok, matched, captures
  end
  local state: GMatchState = {ms = PatternMatcher.create(s, pattern), init = init}
  return gmatch_next, state, (@string){}
end

--[[
Returns a string that is the concatenation of `n` copies of the string `s` separated by the string `sep`.
The default value for `sep` is the empty string (that is, no separator).
Returns the empty string if `n` is not positive.
]]
function string.rep(s: string, n: isize, sep: facultative(string)): string
  if unlikely(n <= 0) then return (@string){} end
  if unlikely(n == 1) then return string.copy(s) end
  local n: usize = (@usize)(n)
  ## if sep.type.is_niltype then
  if unlikely(s.size == 0) then return (@string){} end
  local ret: string = string.create(n * s.size)
  for i:usize=0,<n do
    memory.copy(&ret.data[i*s.size], &s.data[0], s.size)
  end
  ## else
  local sep: string = sep
  local partsize: usize = s.size + sep.size
  if unlikely(partsize <= 0) then return (@string){} end
  local ret: string = string.create(n * partsize - sep.size)
  for i:usize=0,<n do
    memory.copy(&ret.data[i*partsize], &s.data[0], s.size)
    if i ~= n-1 then
      memory.copy(&ret.data[i*partsize + s.size], &sep.data[0], sep.size)
    end
  end
  ## end
  return ret
end

-- Helper used by `string.match` and `string.matchview`.
local function string_match(s: string, pattern: string, init: facultative(isize)): (boolean, sequence(string))
  ## if init.type.is_niltype then
  local init: isize = 1
  ## end
  local ms: PatternMatcher = PatternMatcher.create(s, pattern)
  local startpos: isize, endpos: isize = ms:match(init, false)
  local captures: sequence(string)
  if endpos ~= -1 then
    if ms.numcaptures > 0 then -- has captures
      captures:resize((@usize)(ms.numcaptures))
      for i:isize=0,<ms.numcaptures do
        captures[(@usize)(i+1)] = ms:get_capture(i)
      end
      return true, captures
    else -- nothing captured, then capture whole match
      captures[1] = ms.source:subview(startpos+1, endpos)
      return true, captures
    end
  else -- no match
    return false, captures
  end
end

--[[
Look for the first match of pattern in the string.
If it finds one, then returns true plus a sequence with the captured values,
otherwise it returns false plus an empty sequence.
If pattern specifies no captures, then the whole match is captured.
A third, optional argument specifies where to start the search, its default value is 1 and can be negative.
]]
function string.match(s: string, pattern: string, init: facultative(isize)): (boolean, sequence(string))
  local ok: boolean, seq: sequence(string) = string_match(s, pattern, init)
  for i: isize = 1, #seq do
    seq[i] = string.copy(seq[i])
  end
  return ok, seq
end

-- Like `string.match` but uses sub string views (see also `string.subview`).
function string.matchview(s: string, pattern: string, init: facultative(isize)): (boolean, sequence(string))
  return string_match(s, pattern, init)
end

-- Returns a string that is the string `s` reversed.
function string.reverse(s: string): string
  if unlikely(s.size == 0) then return s end
  local ret: string = string.create(s.size)
  for i:usize=0,<s.size do
    ret.data[i] = s.data[s.size - i - 1]
  end
  return ret
end

--[[
Receives a string and returns a copy of this string with all lowercase letters changed to uppercase.
All other characters are left unchanged.
The definition of what a lowercase letter is depends on the current locale
only if pragma `nobuiltincharclass` is set.
]]
function string.upper(s: string): string
  ## if pragmas.nobuiltincharclass then
  local function toupper(c: cint): cint <cimport,cinclude'<ctype.h>',nosideeffect> end
  ## else
  local function toupper(c: cint): cint <inline> return (@cuint)(c)-'a'_b < 26 and c & 0x5f or c end
  ## end
  if unlikely(s.size == 0) then return s end
  local ret: string = string.create(s.size)
  for i:usize=0,<s.size do
    ret.data[i] = (@byte)(toupper(s.data[i]))
  end
  return ret
end

--[[
Receives a string and returns a copy of this string with all uppercase letters changed to lowercase.
All other characters are left unchanged.
The definition of what an uppercase letter is depends on the current locale
only if pragma `nobuiltincharclass` is set.
]]
function string.lower(s: string): string
  ## if pragmas.nobuiltincharclass then
  local function tolower(c: cint): cint <cimport,cinclude'<ctype.h>',nosideeffect> end
  ## else
  local function tolower(c: cint): cint <inline> return (@cuint)(c)-'A'_b < 26 and c | 32 or c end
  ## end
  if unlikely(s.size == 0) then return s end
  local ret: string = string.create(s.size)
  for i:usize=0,<s.size do
    ret.data[i] = (@byte)(tolower(s.data[i]))
  end
  return ret
end

--[[
Receives zero or more integers and returns a string with length equal to the number of arguments,
in which each character has the internal numeric code equal to its corresponding argument.
Numeric codes are not necessarily portable across platforms.
]]
function string.char(...: varargs): string
  local s: string = string.create(#[select('#', ...)]#)
  ## for i=1,select('#', ...) do
  s.data[#[i-1]#] = #[select(i, ...)]#
  ## end
  return s
end

--[[
Returns a formatted version of its variable number of arguments following the description
given in its first argument, which must be a string.
The format string follows the same rules as the ISO C function `sprintf`.
The only differences are that the conversion specifiers and modifiers `*, h, L, l` are not supported.
]]
function string.format(fmt: string, ...: varargs): string
  local sb: stringbuilder
  sb:writef(fmt, ...)
  return sb:promote()
end

--[[
Receives a string and returns its length.
The empty string "" has length 0. Embedded zeros are counted.
]]
function string.len(s: string): isize <inline>
  return (@isize)(s.size)
end

--[[
Converts a string to a span of bytes.

Remarks: Similar to `subview` a reference of the current string data is returned.
]]
function string.span(s: string): span(byte) <inline>
  return (@span(byte)){data=s.data, size=s.size}
end

--[[
Returns the reference of byte representing the character at index `i`.
Argument `i` must be an integer between 1 and the string size.
Used when indexing elements with square brackets (`[]`).
]]
function string.__atindex(s: string, i: usize): *byte <inline,nosideeffect>
  check(i >= 1 and i <= s.size, 'index out of range')
  return &s.data[i-1]
end

-- Return length of a string. Used by the length operator (`#`).
function string.__len(a: string): isize <inline>
  return (@isize)(a.size)
end

-- Concept to check if a value can possibly be a number.
local scalar_coercion_concept: type = #[concept(function(x)
  if x.type.is_stringy then
    return primtypes.string
  elseif x.type.is_integral then
    return primtypes.integer
  elseif x.type.is_float then
    return primtypes.number
  end
  return false, string.format("type '%s' is not convertible to a scalar", x.type)
end)]#

-- Concatenate two strings. Used by the concatenation operator (`..`).
function string.__concat(a: auto, b: auto): string
  ## if not a.type.is_string then
    local a: string = tostring(a)
    defer a:destroy() end
  ## end
  ## if not b.type.is_string then
    local b: string = tostring(b)
    defer b:destroy() end
  ## end
  if a.size == 0 then
    return string.copy(b)
  elseif b.size == 0 then
    return string.copy(a)
  end
  local s: string = string.create(a.size + b.size)
  memory.copy(s.data, a.data, a.size)
  memory.copy(&s.data[a.size], b.data, b.size)
  return s
end

-- Compare two strings. Used by the equality operator (`==`).
function string.__eq(a: string, b: string): boolean
  return a.size == b.size and (a.data == b.data or a.size == 0 or memory.equals(a.data, b.data, a.size))
end

--[[
Compare if string `a` is less than string `b` in lexicographical order.
Used by the less than operator (`<`).
]]
function string.__lt(a: string, b: string): boolean
  if unlikely(a.size == 0 or b.size == 0) then
    return a.size < b.size
  else
    if a.size < b.size then
      return memory.compare(a.data, b.data, a.size) <= 0
    else
      return memory.compare(a.data, b.data, b.size) < 0
    end
  end
end

--[[
Compare if string `a` is less or equal than string `b` in lexicographical order.
Used by the less or equal than operator (`<=`).
]]
function string.__le(a: string, b: string): boolean
  if unlikely(a.size == 0 or b.size == 0) then
    return a.size <= b.size
  else
    if a.size <= b.size then
      return memory.compare(a.data, b.data, a.size) <= 0
    else
      return memory.compare(a.data, b.data, b.size) < 0
    end
  end
end

--[[
Converts input strings to numbers and returns the result of addition.
Use by the add operator (`+`).
]]
function string.__add(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  local a, b = tonumber(a), tonumber(b)
  return a + b
end

--[[
Converts input strings to numbers and returns the result of subtraction.
Use by the subtract operator (`-`).
]]
function string.__sub(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  local a, b = tonumber(a), tonumber(b)
  return a - b
end

--[[
Converts input strings to numbers and returns the result of multiplication.
Use by the multiply operator (`*`).
]]
function string.__mul(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  local a, b = tonumber(a), tonumber(b)
  return a * b
end

--[[
Converts input strings to numbers and returns the result of division.
Use by the division operator (`/`).
]]
function string.__div(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  local a, b = tonumber(a), tonumber(b)
  return a / b
end

--[[
Converts input strings to numbers and returns the result of floor division.
Use by the integer division operator (`//`).
]]
function string.__idiv(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  local a, b = tonumber(a), tonumber(b)
  return a // b
end

--[[
Converts input strings to numbers and returns the result of truncate division.
Use by the truncate division operator (`///`).
]]
function string.__tdiv(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  local a, b = tonumber(a), tonumber(b)
  return a /// b
end

--[[
Converts input strings to numbers and returns the result of floor division remainder.
Use by the modulo operator (`%`).
]]
function string.__mod(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  local a, b = tonumber(a), tonumber(b)
  return a % b
end

--[[
Converts input strings to numbers and returns the result of truncate division remainder.
Use by the truncate module operator (`%%%`).
]]
function string.__tmod(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  local a, b = tonumber(a), tonumber(b)
  return a %%% b
end

--[[
Converts input strings to numbers and returns the result of exponentiation.
Use by the pow operator (`^`).
]]
function string.__pow(a: scalar_coercion_concept, b: scalar_coercion_concept): number
  local a, b = tonumber(a), tonumber(b)
  return a ^ b
end

--[[
Converts the input string to a number and returns its negation.
Use by the negation operator (`-`).
]]
function string.__unm(a: scalar_coercion_concept): number
  local a = tonumber(a)
  return -a
end

--[[
Converts input strings to integers and returns the result of bitwise AND.
Use by the bitwise AND operator (`&`).
]]
function string.__band(a: scalar_coercion_concept, b: scalar_coercion_concept): integer
  local a, b = tointeger(a), tointeger(b)
  return a & b
end

--[[
Converts input strings to integers and returns the result of bitwise OR.
Use by the bitwise OR operator (`|`).
]]
function string.__bor(a: scalar_coercion_concept, b: scalar_coercion_concept): integer
  local a, b = tointeger(a), tointeger(b)
  return a | b
end

--[[
Converts input strings to integers and returns the result of bitwise XOR.
Use by the bitwise XOR operator (`~`).
]]
function string.__bxor(a: scalar_coercion_concept, b: scalar_coercion_concept): integer
  local a, b = tointeger(a), tointeger(b)
  return a ~ b
end

--[[
Converts input strings to integers and returns the result of bitwise logical left shift.
Use by the bitwise logical left shift operator (`<<`).
]]
function string.__shl(a: scalar_coercion_concept, b: scalar_coercion_concept): integer
  local a, b = tointeger(a), tointeger(b)
  return a << b
end

--[[
Converts input strings to integers and returns the result of bitwise logical right shift.
Use by the bitwise logical right shift operator (`>>`).
]]
function string.__shr(a: scalar_coercion_concept, b: scalar_coercion_concept): integer
  local a, b = tointeger(a), tointeger(b)
  return a >> b
end

--[[
Converts input strings to integers and returns the result of bitwise arithmetic right shift.
Use by the bitwise arithmetic right shift operator (`>>>`).
]]
function string.__asr(a: scalar_coercion_concept, b: scalar_coercion_concept): integer
  local a, b = tointeger(a), tointeger(b)
  return a >>> b
end

--[[
Converts the input string to an integer and returns its bitwise NOT.
Use by the bitwise NOT operator (`~`).
]]
function string.__bnot(a: scalar_coercion_concept): integer
  local a = tointeger(a)
  return ~a
end

-- Helper to check if a byte is a space.
local function isspace(c: byte): boolean <inline>
  return c == ' '_b or (c - '\t'_b < 5)
end

-- Helper to check if a byte is a digit.
local function getdigit(c: byte): byte <inline>
  return c - '0'_b
end

-- Helper to convert a character to a digit number.
local function getbasedigit(c: byte): byte <inline>
  local d: byte = c - '0'_b
  if d < 10 then return d end
  d = c - 'a'_b
  if d < 26 then return d + 10 end
  d = c - 'A'_b
  if d < 26 then return d + 10 end
  return 255
end

-- Convert a string to an integer in the desired base.
local function str2int(s: string, base: uinteger): (boolean, integer)
  if s.size == 0 then return false, 0 end
  local pos: usize = 0
  while pos < s.size and isspace(s.data[pos]) do pos = pos + 1 end -- skip initial spaces
  if pos >= s.size then return false, 0 end
  local neg: boolean = false
  if s.data[pos] == '-'_b then -- negative sign
    pos = pos + 1
    neg = true
  elseif s.data[pos] == '+'_b then -- skip positive sign
    pos = pos + 1
  end
  if base == 0 then -- detect base
    base = 10 -- default to base 10
    if s.data[pos] == '0'_b and pos + 1 < s.size then -- has base prefix
      local bc: byte = s.data[pos+1]
      if bc == 'b'_b or bc == 'B'_b then -- binary
        base = 2
        pos = pos + 2
      elseif bc == 'x'_b or bc == 'X'_b then -- hexadecimal
        base = 16
        pos = pos + 2
      end
    end
  end
  assert(base >= 2 and base <= 36, "base out of range")
  local n: uinteger = 0
  while pos < s.size do
    local x: uinteger = getbasedigit(s.data[pos])
    if x >= base then break end
    n = n * base + (@uinteger)(x)
    pos = pos + 1
  end
  while pos < s.size and isspace(s.data[pos]) do pos = pos + 1 end -- skip trailing spaces
  if pos ~= s.size then return false, 0 end
  if neg then n = -n end -- negate
  return true, (@integer)(n)
end

-- Convert a decimal string to a float number.
local function str2num(s: string): (boolean, number)
  local longfloat: type = #[primtypes.number.is_float32 and primtypes.float64 or primtypes.clongdouble]#
  local num: longfloat, basenum: longfloat = 0, 10
  local base: int32, exp: int32 = 10, 0
  local pos: usize, len: usize = 0, s.size
  -- skip white spaces
  while pos < len and isspace(s.data[pos]) do pos = pos + 1 end
  if pos >= len then return false, 0 end
  -- sign
  local c: byte = s.data[pos]
  local neg: boolean = c == '-'_b
  local gotdigit: boolean, gotfrac: boolean
  if neg or c == '+'_b then pos = pos + 1 end
  -- detect base
  if pos+1 < len and s.data[pos] == '0'_b then
    c = s.data[pos+1]
    if c == 'x'_b or c == 'X'_b then -- hexadecimal
      pos = pos + 2
      base = 16; basenum = 16
    elseif c == 'b'_b or c == 'B'_b then -- binary
      pos = pos + 2
      base = 2; basenum = 2
    end
  end
  -- skip leading zeros
  while pos < len do
    c = s.data[pos]
    if c ~= '0'_b then break end
    pos = pos + 1
    gotdigit = true
  end
  -- mantissa part
  while pos < len do
    c = s.data[pos]
    local d: int32 = getbasedigit(c)
    if d < base then
      num = num * basenum + (@longfloat)(d)
      gotdigit = true
      pos = pos + 1
      if gotfrac then exp = exp - (base == 16 and 4_i32 or 1_i32) end
    elseif c == '.'_b then
      if gotfrac then return false, 0 end
      gotfrac = true
      pos = pos + 1
    else
      break
    end
  end
  if not gotdigit then return false, 0 end
  -- exponent part
  if pos < len and (base == 10 and (c == 'e'_b or c == 'E'_b)) or
                   (base ~= 10 and (c == 'p'_b or c == 'P'_b)) then
    pos = pos + 1
    if pos >= len then return false, 0 end
    c = s.data[pos]
    local negexp: boolean = c == '-'_b
    if negexp or c == '+'_b then pos = pos + 1 end
    if pos >= len or getdigit(s.data[pos]) >= 10 then return false, 0 end
    local e: int32 = 0
    while pos < len do
      local d: int32 = getdigit(s.data[pos])
      if d >= 10 then break end
      e = e * 10 + (@int32)(d)
      if e > 32768 then e = 32768 end -- exponent is too large
      pos = pos + 1
    end
    if negexp then e = -e end
    exp = exp + e
  end
  -- skip white spaces
  while pos < len and isspace(s.data[pos]) do pos = pos + 1 end
  if pos ~= len then return false, 0 end
  -- exponent scale
  if exp ~= 0 then
    local invscale: boolean = exp < 0
    local scale: longfloat = 1
    if invscale then exp = -exp end
    if base == 10 then
      while exp >= 256 do
        scale = scale * (@longfloat)(1e256)
        exp = exp - 256
      end
      ## for _,i in ipairs{128,64,32,16,8,4,2,1} do
        if exp >= #[i]# then
          scale = scale * (@longfloat)(#[tonumber('1e'..i)]#)
          exp = exp - #[i]#
        end
      ## end
    else -- base 2
      local te: longfloat = 2
      while true do
        if exp & 1 == 1 then scale = scale * te end
        exp = exp >>> 1
        if exp == 0 then break end
        te = te * te
      end
    end
    if invscale then scale = 1/scale end
    num = num * scale
  end
  if neg then num = -num end
  return true, (@number)(num)
end

--[[
Fills a `cstring` buffer.
This is mainly used to ensure the string is zero terminated.

Returns `true` in case of success, otherwise `false` when the `buflen` is not enough.
]]
function string.fillcstring(s: string, buf: *[0]cchar, buflen: usize): boolean
  if buf and buflen >= s.size + 1 then
    memory.copy(buf, s.data, s.size)
    buf[s.size] = 0
    return true
  end
  return false
end

-- Convert a value to a string.
global function tostring(x: auto): string
  ##[[
  local xobjtype = x.type:implicit_deref_type()
  local xtype = x.type
  if xtype.is_enum then
    xtype = xtype.subtype
  end
  ]]
  ## if xtype.is_stringy then
    return string.copy(x)
  ## elseif x.type.is_span and x.type.subtype == primtypes.byte then
    return string.copy((@string){data=x.data, size=x.size})
  ## elseif xobjtype.is_record and xobjtype.metafields.__tostring then
    return x:__tostring()
  ## elseif xtype.is_scalar or xtype.is_function or xtype.is_pointer then
    ## if xtype.is_pointer then tyformat = '"0x%" PRIxPTR'
    local x: usize = (@usize)(x)
    if x == 0 then
      return string.copy('(null)')
    end
    ## elseif xtype.is_function then tyformat = '"function: 0x%" PRIxPTR'
    local x: usize = (@usize)((@pointer)(x))
    if x == 0 then
      return string.copy('function: (null)')
    end
    ##[[ else
      tyformat = require'nelua.cdefs'.types_printf_format[xtype.codename]
      static_assert(tyformat, 'cannot handle this scalar type in `tostring`')
    end]]
    local tmpbuf: [48]byte <noinit> -- the output should not have more than 48 characters
    tmpbuf[47] = 0
    local function snprintf(s: cstring, maxlen: csize, format: cstring, ...: cvarargs): cint <cimport,cinclude'<stdio.h>'> end
    local fmt: cstring <cimport(#[tyformat]#), nodecl, cinclude '<inttypes.h>'>
    local len: cint = snprintf(&tmpbuf, #tmpbuf-1, fmt, x)
    ## if xtype.is_float then
      -- add a least one decimal if needed
      local fractnum: boolean
      for i:usize=0,<len do
        if not (getdigit(tmpbuf[i]) < 10 or tmpbuf[i] == '-'_b) then
          fractnum = true
          break
        end
      end
      if not fractnum and len > 0 and len + 2 < #tmpbuf then
        tmpbuf[len] = '.'_b
        tmpbuf[len+1] = '0'_b
        len = len + 2
      end
    ## end
    assert(len >= 0 and len < #tmpbuf-1, "tostring format failed or truncated")
    return string.copy((@string){&tmpbuf[0], len})
  ## elseif xtype.is_boolean then
    if x == true then
      return string.copy('true')
    end
    return string.copy('false')
  ## elseif xtype.is_niltype then
    return string.copy('nil')
  ## elseif xtype.is_nilptr then
    return string.copy('(null)')
  ## elseif xtype.is_polyfunction then
    return string.copy('polyfunction')
  ## else static_error("tostring: cannot convert type '%s' to a string", xtype) end
end

-- Convert a value to a number.
global function tonumber(x: auto, base: facultative(integer)): auto
  -- TODO: return nil in case of fail (like lua)
  ## if not base.type.is_niltype then
    ## static_assert(x.type.is_stringy, "string expected, got something else")
    local ok: boolean, i: integer = str2int(x, base)
    assert(ok, 'malformed integral number')
    return i
  ## elseif x.type.is_integral then
    return (@integer)(x)
  ## elseif x.type.is_float then
    return (@number)(x)
  ## elseif x.type.is_stringy then
    local ok: boolean, n: number = str2num(x)
    assert(ok, 'malformed number')
    return n
  ## else static_error("unable to convert value of type '%s' to a number", x.type) end
end

-- Convert a value to an integer.
global function tointeger(x: auto, base: facultative(integer)): integer
  ## if not base.type.is_niltype then
    ## static_assert(x.type.is_stringy, "string expected, got something else")
    local ok: boolean, i: integer = str2int(x, base)
    assert(ok, 'malformed integer')
    return i
  ## elseif x.type.is_scalar then
    return (@integer)(x)
  ## elseif x.type.is_stringy then
    local ok: boolean, i: integer = str2int(x, 0)
    assert(ok, 'malformed integer')
    return i
  ## else static_error("unable to convert value of type '%s' to an integer", x.type) end
end

-- Max alignment for pack.
local PACKMAXALIGN: usize <comptime> =
  #[math.max(primtypes.float64.align, primtypes.pointer.align, primtypes.integer.align, primtypes.number.align)]#

-- Helper to get native endianness.
local function isnativelittle(): boolean <inline>
  local u: union{dummy: int32, little: int8} = {little=1}
  return u.little == 1
end

-- Aligns forward `addr` to the minimum of `align` and `maxalign` bytes.
local function packalignforward(addr: usize, align: usize, maxalign: usize): usize <inline>
  if align > maxalign then align = maxalign end
  if align <= 1 then return addr end
  local alignbits: usize = align - 1
  assert(align & alignbits == 0, "format asks for alignment not power of 2")
  return (addr + alignbits) & ~alignbits
end

--[[
Pack integer `n` with `size` bytes and `islittle` endianness.
The final 'if' handles the case when `size` is larger than the size of a uint64,
correcting the extra sign-extension bytes if necessary (by default they would be zeros).
]]
local function packint(sb: *stringbuilder, a: auto, size: usize, maxalign: usize, islittle: boolean): boolean
  ## if a.type.is_integral then
  local neg: boolean = a < 0
  local n: uint64 = (@uint64)(a)
  ## else
  local i: integer = tointeger(a)
  local neg: boolean = i < 0
  local n: uint64 = (@uint64)(i)
  ## end
  -- TODO: we could do overflow checks here (like Lua does)
  local pads: usize = packalignforward(sb.size, size, maxalign) - sb.size
  if not sb:writebyte(0, pads) then return false end
  local buff: span(byte) = sb:prepare(size)
  if buff:empty() then return false end
  buff[islittle and 0 or size - 1] = n & 0xff -- first byte
  for i: usize=1,<size do
    n = n >> 8
    buff[islittle and i or size-1-i] = n & 0xff
  end
  if size > #@uint64 and neg then -- negative number, need sign extension?
    for i: usize=#@uint64,<size do
      buff[islittle and i or size-1-i] = 0xff
    end
  end
  sb:commit(size)
  return true
end

--[[
Unpack an integer with `size` bytes and `islittle` endianness.
If size is smaller than the size of a uint64 and integer is signed,
must do sign extension (propagating the sign to the higher bits).
Ff size is larger than the size of a uint64,
it must check the unread bytes to see whether they do not cause an overflow.
]]
local function unpackint(s: string, pos: *usize, size: usize, maxalign: usize, islittle: boolean, issigned: boolean): uint64
  local pads: usize = packalignforward($pos, size, maxalign) - $pos
  assert($pos + pads + size <= s.size, 'data string too short')
  local buff: *[0]byte = &s.data[$pos + pads]
  local n: uint64 = 0
  local limit: isize = size <= #@uint64 and (@isize)(size) or #@uint64
  for i: isize=limit-1,0,-1 do
    n = (n << 8) | (@uint64)(buff[islittle and (@usize)(i) or size-(@usize)(i+1)])
  end
  if size < #@uint64 then -- real size smaller than uint64
    if issigned then -- needs sign extension?
      local mask: uint64 = 1_uint64 << (size*8 - 1)
      n = (n ~ mask) - mask -- do sign extension
    end
  elseif size > #@uint64 then -- must check unread bytes
    local mask: uint64 = (not issigned or (@int64)(n) >= 0) and 0_u64 or 0xff_u64
    for i: usize=(@usize)(limit),<size do
      assert(buff[islittle and i or size-1-i] == mask, 'integer does not fit into int64')
    end
  end
  $pos = $pos + pads + size
  return n
end

-- Copy `size` bytes from `src` into `dest`, respecting system endiness.
local function packcopy(dest: pointer, src: *[0]byte, size: usize, islittle: boolean): void <inline>
  if likely(islittle == isnativelittle()) then -- same endianess
    memory.copy(dest, src, size)
  else -- different endianess, copy bytes in reverse order
    local buff: *[0]byte = (@*[0]byte)(dest)
    for i:usize=0,<size do
      buff[size-1-i] = src[i]
    end
  end
end

-- Copy `size` bytes from `src` to `dest`, correcting endianness if `keependian` is false.
local function packnum(sb: *stringbuilder, a: auto, T: type, maxalign: usize, islittle: boolean): boolean
  local pads: usize = packalignforward(sb.size, #@T, maxalign) - sb.size
  if not sb:writebyte(0, pads) then return false end
  local buff: span(byte) = sb:prepare(#@T)
  if buff:empty() then return false end
  ## if T.value.is_float and not a.type.is_float then
  local v: T = (@T)(tonumber(a))
  ## elseif T.value.is_integral and not a.type.is_integral then
  local v: T = (@T)(tointeger(a))
  ## else
  local v: T = (@T)(a)
  ## end
  packcopy(buff.data, (@*[0]byte)(&v), #@T, islittle)
  sb:commit(#@T)
  return true
end

-- Read an integer from string `fmt` starting at `pos`, returns `def` if there is no number.
local function packgetnum(fmt: string, pos: *usize, def: usize): usize
  local init: usize = $pos
  local n: usize = 0
  while $pos < fmt.size do
    local d: usize = getdigit(fmt.data[$pos])
    if d >= 10 then break end
    n = n*10 + d
    $pos = $pos + 1
  end
  return $pos ~= init and n or def
end

-- Like `packgetnum` but checks if the number is in range [1,16].
local function packgetnumlimit(fmt: string, pos: *usize, def: usize): usize
  local n: usize = packgetnum(fmt, pos, def)
  assert(n > 0 and n <= 16, 'integral size out of limits [1,16]')
  return n
end

-- Get size of the option following 'X' option.
local function packgetoptalign(fmt: string, pos: *usize): usize
  local align: usize = 0
  if $pos < fmt.size then
    local c: byte = fmt.data[$pos]
    $pos = $pos + 1
    switch c
    case 's'_b then align = packgetnumlimit(fmt, pos, #@usize)
    case 'i'_b, 'I'_b then align = packgetnumlimit(fmt, pos, #@cint)
    case 'b'_b, 'B'_b, 'x'_b then align = #@byte
    case 'h'_b, 'H'_b then align = #@cshort
    case 'l'_b, 'L'_b then align = #@clong
    case 'j'_b, 'J'_b then align = #@integer
    case 't'_b, 'T'_b then align = #@usize
    case 'f'_b then align = #@float32
    case 'd'_b then align = #@float64
    case 'n'_b then align = #@number
    end
  end
  assert(align > 0, "invalid next option for pack option 'X'")
  return align
end

-- Packs an argument.
local function packarg(a: auto, c: byte, sb: *stringbuilder, fmt: string, pos: *usize, maxalign: usize, islittle: boolean): boolean
  switch c
  case 'z'_b then -- zero-terminated string
    local ok: boolean, written: usize = sb:write(a)
    if not ok then return false end
    assert(written == 0 or not memory.scan(&sb.data[sb.size - written], 0, written), 'string contains zeros')
    return sb:writebyte(0) -- zero at the end
  case 'c'_b then -- fixed-size string
    local n: usize = packgetnum(fmt, pos, 0)
    local ok: boolean, written: usize = sb:write(a)
    if not ok then return false end
    assert(n >= written, 'string longer than given size')
    return sb:writebyte(0, n - written)
  case 's'_b then -- string preceded by its length
    local n: usize = packgetnumlimit(fmt, pos, #@usize)
    ## if a.type.is_stringy then
    local s: string = a
    ## else
    local s: string = tostring(a)
    defer s:destroy() end
    ## end
    assert(n >= #@usize or s.size < 1_usize << (n * 8), 'length does not fit in given size')
    return packint(sb, s.size, n, maxalign, islittle) and sb:write(s)
  case 'i'_b, 'I'_b then return packint(sb, a, packgetnumlimit(fmt, pos, #@cint), maxalign, islittle)
  case 'b'_b, 'B'_b then return packnum(sb, a, @byte, maxalign, islittle)
  case 'h'_b, 'H'_b then return packnum(sb, a, @cushort, maxalign, islittle)
  case 'l'_b, 'L'_b then return packnum(sb, a, @culong, maxalign, islittle)
  case 'j'_b, 'J'_b then return packnum(sb, a, @uinteger, maxalign, islittle)
  case 't'_b, 'T'_b then return packnum(sb, a, @usize, maxalign, islittle)
  case 'f'_b then return packnum(sb, a, @float32, maxalign, islittle)
  case 'd'_b then return packnum(sb, a, @float64, maxalign, islittle)
  case 'n'_b then return packnum(sb, a, @number, maxalign, islittle)
  else return assert(false, #[string.format("invalid pack format option")]#) end
end

--[[
Returns a binary string containing the values in `...`,
serialized in binary form (packed) according to the format string `fmt`.

For description of the format options,
see [Lua's format strings for pack](https://www.lua.org/manual/5.4/manual.html#6.4.2).
]]
function string.pack(fmt: string, ...: varargs): string
  local sb: stringbuilder
  local pos: usize, argi: usize, maxalign: usize = 0, 0, 1
  local ok: boolean, islittle: boolean = true, isnativelittle()
  while pos < fmt.size do
    local c: byte = fmt.data[pos]
    pos = pos + 1
    switch c
    case ' '_b then -- ignore
    case '<'_b then islittle = true
    case '>'_b then islittle = false
    case '='_b then islittle = isnativelittle()
    case '!'_b then maxalign = packgetnumlimit(fmt, &pos, PACKMAXALIGN)
    case 'X'_b then ok = sb:writebyte(0, packalignforward(sb.size, packgetoptalign(fmt, &pos), maxalign) - sb.size)
    case 'x'_b then ok = sb:writebyte(0)
    else
      argi = argi + 1
      ## for i=1,select('#', ...) do
      if argi == #[i]# then
        ok = packarg(#[select(i, ...)]#, c, &sb, fmt, &pos, maxalign, islittle)
        goto next
      end
      ## end
      assert(false, "missing argument in pack format")
      ::next::
    end
    assert(ok, 'out of memory')
  end
  return sb:promote()
end

--[[
Returns the values packed in string `s` (see `string.pack`) according to the format string `fmt`.
An optional `init` marks where to start reading in `s` (default is `1`).
After the read values, this function also returns the index of the first unread byte in `s`.

For description of the format options,
see [Lua's format strings for pack](https://www.lua.org/manual/5.4/manual.html#6.4.2).

Remarks: `fmt` must be a compile-time string.
]]
function string.unpack(fmt: string <comptime>, s: string, init: facultative(isize))
  ## if init.type.is_niltype then
  local pos: usize = 0
  ## else
  if unlikely(init < 0) then init = (@usize)(s.size) + init + 1 end
  if unlikely(init <= 0) then init = 1 end
  local pos: usize = (@usize)(init - 1)
  ## end
  local islittle: boolean, maxalign: usize = isnativelittle(), 1
  ##[[
  local formattypes = {
    b = primtypes.int8, B = primtypes.uint8,
    h = primtypes.cshort, H = primtypes.cushort,
    l = primtypes.clong, L = primtypes.culong,
    i = primtypes.cint, I = primtypes.cuint,
    j = primtypes.integer, J = primtypes.uinteger,
    t = primtypes.isize, T = primtypes.usize,
    f = primtypes.float32, d = primtypes.float64, n = primtypes.number,
  }
  local inttypes = {
    i1 = primtypes.int8, i2 = primtypes.int16, i4 = primtypes.int32, i8 = primtypes.int64,
    I1 = primtypes.uint8, I2 = primtypes.uint16, I4 = primtypes.uint32, I8 = primtypes.uint64,
  }
  local fmt, fpos, iarg, retargs = fmt.value, 1, 0, {}
  local function unpackgetopt()
    local c = fmt:sub(fpos, fpos)
    fpos = fpos + 1
    return c
  end
  local function unpackgetnum(req, lim)
    local n = fmt:match('^[0-9]+', fpos)
    if n then
      fpos = fpos + #n
      n = tonumber(n)
      if lim then
        static_assert(n > 0 and n <= 16, 'integral size out of limits [1,16]')
      end
    end
    static_assert(n or not req, 'missing number in format pack option')
    return n
  end
  local function unpackgetoptalign()
    local align
    local c = unpackgetopt()
    if c == 's' then align = unpackgetnum(false, true) or primtypes.usize
    elseif c == 'i' or c == 'I' then align = unpackgetnum(false, true) or primtypes.cint
    elseif c == 'b' or c == 'B' or c == 'x' then align = primtypes.byte
    elseif c == 'h' or c == 'H' then align = primtypes.cshort
    elseif c == 'l' or c == 'L' then align = primtypes.clong
    elseif c == 'j' or c == 'J' then align = primtypes.integer
    elseif c == 't' or c == 'T' then align = primtypes.usize
    elseif c == 'f' then align = primtypes.float32
    elseif c == 'd' then align = primtypes.float64
    elseif c == 'n' then align = primtypes.number
    end
    static_assert(align, "invalid next option for pack option 'X'")
    return align
  end
  while fpos <= #fmt do
    local c = unpackgetopt()
    iarg = iarg + 1
    local argname = 'a'..iarg
    ]]
    ## if c == ' ' then -- space is ignored
    ## elseif c == '<' then -- sets little endian
      islittle = true
    ## elseif c == '>' then -- sets big endian
      islittle = false
    ## elseif c == '=' then -- sets native endian
      islittle = isnativelittle()
    ## elseif c == '!' then -- sets maximum alignment
      ## local align = unpackgetnum(false, true)
      maxalign = #[align or PACKMAXALIGN]#
    ## elseif c == 'X' then -- aligns according to option
      ## local align = unpackgetoptalign()
      ## if math.type(align) == 'integer' then
      pos = packalignforward(pos, #[align]#, maxalign)
      ## else
      pos = packalignforward(pos, # #[align]#, maxalign)
      ## end
    ## elseif c == 'x' then -- one byte of padding
      assert(pos + #@byte <= s.size, 'data string too short')
      pos = pos + #@byte
    ## elseif c == 'z' then -- zero-terminated string
      local zptr: pointer = memory.scan(&s.data[pos], 0, s.size - pos)
      assert(zptr, 'string zero termination not found')
      local len: usize = (@usize)(zptr) - (@usize)(&s.data[pos])
      local #|argname|#: string = string.copy((@string){data=&s.data[pos], size=len})
      pos = pos + len + 1
      ## retargs[#retargs+1] = aster.Id{argname}
    ## elseif c == 'c' then -- fixed-size string
      local len: usize = #[unpackgetnum(true)]#
      assert(pos + len <= s.size, 'data string too short')
      local #|argname|#: string = string.copy((@string){data=&s.data[pos], size=len})
      pos = pos + len
      ## retargs[#retargs+1] = aster.Id{argname}
    ## elseif c == 's' then -- string preceded by its length
      ## local n = unpackgetnum(false, true)
      ## if n then
      local lensize: usize = #[n]#
      ## else
      local lensize: usize = #@usize
      ## end
      local len: usize = unpackint(s, &pos, lensize, maxalign, islittle, false)
      assert(pos + len <= s.size, 'data string too short')
      local #|argname|#: string = string.copy((@string){data=&s.data[pos], size=len})
      pos = pos + len
      ## retargs[#retargs+1] = aster.Id{argname}
    ## elseif (c == 'i' or c == 'I') and fmt:find('^[0-9]+', fpos) then -- sized signed integer
      ## local n = unpackgetnum(nil, true)
      ## local argtype = inttypes[c..n] or (c == 'i' and primtypes.int64 or primtypes.uint64)
      local #|argname|#: #[argtype]# = (@#[argtype]#)(unpackint(s, &pos, #[n]#, maxalign, islittle, #[c == 'i']#))
      ## retargs[#retargs+1] = aster.Id{argname}
    ## elseif formattypes[c] then -- primitive type
      local T: type = #[ formattypes[c] ]#
      local #|argname|#: T
      local pads: usize = packalignforward(pos, #@T, maxalign) - pos
      assert(pos + pads + #@T <= s.size, 'data string too short')
      packcopy(&#|argname|#, &s.data[pos + pads], #@T, islittle)
      pos = pos + pads + #@T
      ## retargs[#retargs+1] = aster.Id{argname}
    ## else static_error("invalid pack format option '"..c.."'") end
  ## end
  local lastindex: isize = (@isize)(pos + 1)
  ## retargs[#retargs+ 1] = aster.Id{'lastindex'}
  return #[aster.unpack(retargs)]#
end

--[[
Returns the size of a string resulting from string.pack with the given format.
The format string cannot have the variable-length options 's' or 'z'.

For description of the format options,
see [Lua's format strings for pack](https://www.lua.org/manual/5.4/manual.html#6.4.2).
]]
function string.packsize(fmt: string): isize
  local pos: usize, len: usize, n: usize, maxalign: usize = 0, 0, 0, 1
  while pos < fmt.size do
    local c: byte = fmt.data[pos]
    pos = pos + 1
    switch c
    case ' '_b, '<'_b, '>'_b, '='_b then -- ignore
    case '!'_b then maxalign = packgetnumlimit(fmt, &pos, PACKMAXALIGN)
    case 'X'_b then len = packalignforward(len, packgetoptalign(fmt, &pos), maxalign)
    case 'x'_b, 'b'_b, 'B'_b then len = len + #@byte
    case 'c'_b then len = len + packgetnum(fmt, &pos, 0)
    case 'i'_b, 'I'_b then n = packgetnumlimit(fmt, &pos, #@cint) len = packalignforward(len, n, maxalign) + n
    case 'h'_b, 'H'_b then len = packalignforward(len, #@cshort, maxalign) + #@cshort
    case 'l'_b, 'L'_b then len = packalignforward(len, #@clong, maxalign) + #@clong
    case 'j'_b, 'J'_b then len = packalignforward(len, #@integer, maxalign) + #@integer
    case 't'_b, 'T'_b then len = packalignforward(len, #@usize, maxalign) + #@usize
    case 'f'_b then len = packalignforward(len, #@float32, maxalign) + #@float32
    case 'd'_b then len = packalignforward(len, #@float64, maxalign) + #@float64
    case 'n'_b then len = packalignforward(len, #@number, maxalign) + #@number
    else assert(false, 'invalid pack format option') end
  end
  return (@isize)(len)
end
