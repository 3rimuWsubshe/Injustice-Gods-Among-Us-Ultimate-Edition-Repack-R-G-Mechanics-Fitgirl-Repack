require 'span'
require 'memory'
--require 'allocators.generic'

require 'allocators.gc'
local allocator = @gc_allocator

-- C imports
local errno: cint <cimport,cinclude'<errno.h>',nodecl>
local function strlen(s: cstring): csize <cimport,cinclude'<string.h>',nodecl> end
local function toupper(c: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end
local function tolower(c: cint): cint <cimport,cinclude'<ctype.h>',nodecl> end
local function strtoll(str: cstring, endptr: cstring*, base: cint): clonglong <cimport,cinclude'<stdlib.h>',nodecl> end
local function strtod(str: cstring, endptr: cstring*): float64 <cimport,cinclude'<stdlib.h>',nodecl> end

local string_object <codename 'nelua_string_object'> = @record{
  --refs: usize,
  size: usize,
  data: byte[0]
}

global string <codename 'nelua_string'> = @record{
  impl: string_object*
}

##[[
  local stringtype = context.rootscope.symbols.string.value
  stringtype.is_string = true
  stringtype.nick = 'string'
  stringtype.name = 'string'
  primtypes.stringview.metatype = types.MetaType()
  primtypes.stringview.metatype:inherit(stringtype.metatype)
]]

function string._create(size: usize <autocast>): string <inline>
  local self: string
  check(size > 0, 'cannot create string with size 0')
  self.impl = (@string_object*)(allocator.alloc(#@string_object + size + 1))
  self.impl.data[size] = 0
  self.impl.size = size
  --self.impl.refs = 1
  return self
end

function string:reset() <inline>
  self.impl = nilptr
end

function string.fromspan(s: span(byte)): string
  if unlikely(s.size == 0) then return (@string){} end
  local self = string._create(s.size)
  memory.copy(&self.impl.data[0], s.data, s.size)
  return self
end

function string.fromcstring(s: cstring): string <inline>
  if unlikely(not s) then return (@string){} end
  local size: usize = strlen(s)
  if unlikely(size == 0) then return (@string){} end
  local self: string = string._create(size)
  memory.copy(&self.impl.data[0], s, size)
  return self
end

--[[
function string:__copy(o: string*) <inline>
  self.impl = o.impl
  if likely(self.impl) then
    self.impl.refs = self.impl.refs + 1
  end
end

function string:__destroy() <inline>
  if unlikely(not self.impl) then return end
  self.impl.refs = self.impl.refs - 1
  if self.impl.refs == 0 then
    allocator.dealloc(self.impl)
    self.impl = nilptr
  end
end
]]

local empty_cstring: cstring <const> = ''
function string.__tocstring(s: string): cstring <inline>
  if unlikely(not s.impl) then return empty_cstring end
  return (@cstring)(&s.impl.data[0])
end

function string.__tostringview(s: string): stringview <inline>
  if unlikely(not s.impl) then return (@stringview){} end
  return (@stringview){data = (@cstring)(&s.impl.data[0]), size = s.impl.size}
end

function string.__convert(s: #[concept(function(s)
    return s.type.is_stringview or s.type.is_cstring
  end)]#): string <inline>
  ## if s.type.is_stringview then
    return (@string){impl=(@string_object*)(s)}
  ## elseif s.type.is_cstring then
    return string.fromcstring(s)
  ## end
end

global function tostring(x: auto): string
  ## if x.type.is_arithmetic then
    local size: cint
    ##[[
    local tyformat = require'nelua.cdefs'.types_printf_format[x.type.codename]
    staticassert(tyformat)
    cinclude '<stdio.h>'
    cemit('size = snprintf(NULL, 0, '..tyformat..', x);')
    ]]
    if unlikely(size == 0) then return (@string){} end
    local self: string = string._create(size)
    local dest: cstring = (@cstring)(&self.impl.data[0])
    local n: csize = (@csize)(size+1)
    ## cemit('snprintf(dest, n, '..tyformat..', x);')
    return self
  ## elseif x.type.is_boolean then
    if x == true then
      return 'true'
    end
    return 'false'
  ## else
  ##   staticerror("tostring: cannot convert type '%s' to a string", x.type)
  ## end
end

function stringview.__tostring(s: stringview) <inline>
  if unlikely(s.size == 0) then return (@string){} end
  local ret: string = string._create(s.size)
  memory.copy(&ret.impl.data[0], s.data, s.size)
  return ret
end

function string.__len(a: stringview): isize <inline>
  return (@isize)(a.size)
end

function string.__eq(a: stringview, b: stringview): boolean
  return a.size == b.size and (a.size == 0 or memory.equals(a.data, b.data, a.size))
end

function string.__lt(a: stringview, b: stringview): boolean
  if unlikely(a.size == 0 or b.size == 0) then
    return a.size < b.size
  else
    if a.size < b.size then
      return memory.compare(a.data, b.data, a.size) <= 0
    else
      return memory.compare(a.data, b.data, b.size) < 0
    end
  end
end

function string.__le(a: stringview, b: stringview): boolean
  if unlikely(a.size == 0 or b.size == 0) then
    return a.size <= b.size
  else
    if a.size <= b.size then
      return memory.compare(a.data, b.data, a.size) <= 0
    else
      return memory.compare(a.data, b.data, b.size) < 0
    end
  end
end

function string.__concat(a: stringview, b: stringview): string
  if a.size == 0 then
    return b
  elseif b.size == 0 then
    return a
  end
  local s: string = string._create(a.size + b.size)
  memory.copy(&s.impl.data[0], a.data, a.size)
  memory.copy(&s.impl.data[a.size], b.data, b.size)
  return s
end

function string.len(self: stringview): isize <inline>
  return (@isize)(self.size)
end

function string.byte(self: string, i: isize <autocast>): byte
  if unlikely(not self.impl) then return 0 end
  if unlikely(i < 0) then
    i = self.impl.size + i + 1
  end
  --TODO: return nil instead on failure
  check(i >= 1 and i <= self.impl.size, 'string.byte: index out of range')
  return self.impl.data[i-1]
end

function string.sub(self: string, i: isize <autocast>, j: isize <autocast>): string
  if unlikely(not self.impl) then return self end
  if unlikely(i < 0) then i = self.impl.size + i + 1 end
  if unlikely(i <= 0) then i = 1 end
  if unlikely(j < 0) then j = self.impl.size + j + 1 end
  if unlikely(j > self.impl.size) then j = self.impl.size end
  if unlikely(i == 1 and j == self.impl.size) then return self end
  if unlikely(i > j) then return (@string){} end
  local size: usize = (@usize)(j - i + 1)
  if unlikely(size == 0) then return (@string){} end
  local s: string = string._create(size)
  memory.copy(&s.impl.data[0], &self.impl.data[i-1], size)
  return s
end

function string.rep(self: string, n: isize <autocast>): string
  if unlikely(not self.impl or n <= 0) then return (@string){} end
  if unlikely(n == 1) then return self end
  local s: string = string._create(n * self.impl.size)
  for i:isize=0,<n do
    memory.copy(&s.impl.data[i*self.impl.size], &self.impl.data[0], self.impl.size)
  end
  return s
end

function string.reverse(self: string): string
  if unlikely(not self.impl) then return self end
  local s: string = string._create(self.impl.size)
  for i:usize=0,<self.impl.size do
    s.impl.data[i] = self.impl.data[self.impl.size - i - 1]
  end
  return s
end

function string.upper(self: string): string
  if unlikely(not self.impl) then return self end
  local s: string = string._create(self.impl.size)
  for i:usize=0,<self.impl.size do
    s.impl.data[i] = (@byte)(toupper(self.impl.data[i]))
  end
  return s
end

function string.lower(self: string): string
  if unlikely(not self.impl) then return self end
  local s: string = string._create(self.impl.size)
  for i:usize=0,<self.impl.size do
    s.impl.data[i] = (@byte)(tolower(self.impl.data[i]))
  end
  return s
end

function string.char(c: byte)
  --TODO: handle more arguments
  local s: string = string._create(1)
  s.impl.data[0] = c
  return s
end

function string.find(self: string,
                     pattern: stringview,
                     init: isize <autocast>,
                     plain: boolean): (isize, isize)
  --TODO: handle patterns and returns them
  --TODO: return nil if not found instead of zeros
  check(plain, 'string.find: patterns not supported yet')
  if unlikely(not self.impl) then return pattern.size == 0 and 1 or 0, 0 end
  if unlikely(init < 0) then init = self.impl.size + init + 1 end
  if unlikely(init > self.impl.size) then return 0, 0 end
  if unlikely(init <= 0) then init = 1 end
  local found = memory.find(&self.impl.data[init-1], self.impl.size, pattern.data, pattern.size)
  if found then
    local sbegin: isize = (@isize)((@usize)(found) - (@usize)(&self.impl.data[0]))
    return sbegin + 1, sbegin + pattern.size
  end
  return 0, 0
end

-- TODO: implement functions bellow
-- string.format(fmt, ...)
-- string:match(pattern, init)
-- string:gmatch(pattern)
-- string:gsub(pattern, repl, n)
-- string.pack(fmt, v1, v2, ..)
-- string.unpack(fmt, s, pos)
-- string.packsize(fmt)

local function str2int(a: stringview): integer
  local endptr: cstring
  errno = 0
  local i: clonglong = strtoll(a.data, &endptr, 10)
  check(endptr ~= a.data and errno == 0, 'failed to convert string to integer')
  return (@integer)(i)
end

local function str2num(a: stringview): number
  local endptr: cstring
  errno = 0
  local n: float64 = strtod(a.data, &endptr)
  check(endptr ~= a.data and errno == 0, 'failed to convert string to number')
  return n
end
function string.__add(a: stringview, b: stringview): number
  return str2num(a) + str2num(b)
end

function string.__sub(a: stringview, b: stringview): number
  return str2num(a) - str2num(b)
end

function string.__mul(a: stringview, b: stringview): number
  return str2num(a) * str2num(b)
end

function string.__div(a: stringview, b: stringview): number
  return str2num(a) / str2num(b)
end

function string.__idiv(a: stringview, b: stringview): number
  return str2num(a) // str2num(b)
end

function string.__mod(a: stringview, b: stringview): number
  return str2num(a) % str2num(b)
end

function string.__pow(a: stringview, b: stringview): number
  return str2num(a) ^ str2num(b)
end

function string.__unm(a: stringview): number
  return -str2num(a)
end

function string.__band(a: stringview, b: stringview): integer
  return str2int(a) & str2int(b)
end

function string.__bor(a: stringview, b: stringview): integer
  return str2int(a) | str2int(b)
end

function string.__bxor(a: stringview, b: stringview): integer
  return str2int(a) ~ str2int(b)
end

function string.__shl(a: stringview, b: stringview): integer
  return str2int(a) << str2int(b)
end

function string.__shr(a: stringview, b: stringview): integer
  return str2int(a) >> str2int(b)
end

function string.__bnot(a: stringview): integer
  return ~str2int(a)
end
