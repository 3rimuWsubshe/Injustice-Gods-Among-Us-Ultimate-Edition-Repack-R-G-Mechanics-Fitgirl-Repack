-- Nelua global basic functions

do -- C imports
##[[cemitdecl([=[#ifdef __GNUC__
#define nelua_likely(x) __builtin_expect(x, 1)
#define nelua_unlikely(x) __builtin_expect(x, 0)
#else
#define nelua_likely(x) (x)
#define nelua_unlikely(x) (x)
#endif
]=])]]
end

local FILE <cimport,nodecl,forwarddecl,cinclude'<stdio.h>'> = @record{}
local stderr: *FILE <cimport,nodecl,cinclude'<stdio.h>'>
local function fwrite(ptr: *void, size: csize, n: csize, s: *FILE): csize <cimport'fwrite',nodecl,cinclude'<stdio.h>'> end
local function fprintf(stream: *FILE, format: cstring, ...: cvarargs): cint <cimport,nodecl,cinclude'<stdlib.h>'> end
local function fputc(c: cint, stream: *FILE): cint <cimport,nodecl,cinclude'<stdio.h>'> end
local function fflush(stream: *FILE): cint <cimport,nodecl,cinclude'<stdio.h>'> end
local function abort(): void <cimport,nodecl,cinclude'<stdlib.h>'> end
local function exit(status: cint): void <cimport,cinclude'<stdlib.h>',nodecl> end

global function likely(x: boolean): boolean <cimport 'nelua_likely', nodecl> end
global function unlikely(x: boolean): boolean <cimport 'nelua_unlikely', nodecl> end

local function abort() <noreturn>
  ## if pragmas.noabort then
  exit(-1)
  ## else
  abort()
  ## end
end

global function error(msg: auto): void <noreturn>
  ## if msg.type.is_niltype then
  local msg: stringview = 'error!'
  ## elseif msg.type.is_cstring then
  local msg: stringview = msg
  ## elseif not msg.type.is_stringy then static_error 'error message is not a string' end
  fwrite(msg.data, msg.size, 1, stderr)
  fputc('\n'_cchar, stderr)
  fflush(stderr)
  abort()
end

local function assert_format(cond: boolean, fmt: cstring, msg: cstring): void
  if unlikely(not cond) then
    fprintf(stderr, fmt, msg)
    fflush(stderr)
    abort()
  end
end

global function assert(cond: auto, msg: auto) <alwayseval>
  ## local text = context.state.inpolyeval.srcnode:format_message('runtime error', '%s')
  ## if cond.type.is_niltype then
  local cond: boolean = false
  ## end
  ## if msg.type.is_niltype then
  assert_format(cond, #[text]#, 'assertion failed!'_cstring)
  ## elseif msg.type.is_stringy then
  assert_format(cond, #[text]#, msg)
  ## else static_error('error object is a %s', msg.type) end
  return cond
end

--[[
global function warn(msg: stringview)
  local warn_enabled: boolean <static> = false
  if msg == '@on' then
    warn_enabled = true
  elseif msg == '@off' then
    warn_enabled = false
  else
    if warn_enabled then
      print('Nelua warning:', msg)
    end
  end
end
]]

--[[
global function load()
  error('not implemented yet')
end

global function loadfile()
  error('not implemented yet')
end

global function pcall()
  error('not implemented yet')
end

global function xpcall()
  error('not implemented yet')
end

global function rawequal()
  error('not implemented yet')
end

global function rawget()
  error('not implemented yet')
end

global function rawlen()
  error('not implemented yet')
end

global function rawset()
  error('not implemented yet')
end

global function setmetatable()
  error('not implemented yet')
end

global function getmetatable()
  error('not implemented yet')
end

global function select()
  error('not implemented yet')
end
]]

-- pairs/ipairs/next is implemented in iterators.nelua
-- tostring/tonumber is implemented in stringview.nelua/string.nelua
-- type is implemented in traits.nelua
-- require is implemented by the nelua compiler
-- collectgarbage is implemented in allocators/gc.nelua
-- TODO: move print to here

-- Global variable that holds a string containing the running Nelua version.
global _VERSION: stringview <comptime> = "Nelua 0.2"
--_G
