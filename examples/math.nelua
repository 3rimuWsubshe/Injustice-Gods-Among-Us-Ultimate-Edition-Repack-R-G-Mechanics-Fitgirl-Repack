--TODO: function type overload
--TODO: become a module
--TODO: string compare

!!cinclude '<math.h>'
!!cinclude '<stdlib.h>'

local math = @record{}

global math.pi: compconst = 3.141592653589793
global math.maxinteger: compconst = 9223372036854775807
global math.mininteger: compconst = -9223372036854775807-1
global math.huge: number !cimport 'HUGE_VAL'

function math.abs(x: number): number !cimport('fabs') end
function math.ceil(x: number): number !cimport('ceil') end
function math.floor(x: number): number !cimport('floor') end
function math.max(x: number, y: number): number !cimport('fmax') end
function math.min(x: number, y: number): number !cimport('fmin') end
function math.acos(x: number): number !cimport('acos') end
function math.asin(x: number): number !cimport('asin') end
function math.atan(x: number): number !cimport('atan') end
function math.cos(x: number): number !cimport('cos') end
function math.sin(x: number): number !cimport('sin') end
function math.tan(x: number): number !cimport('tan') end
function math.sqrt(x: number): number !cimport('sqrt') end
function math.exp(x: number): number !cimport('exp') end
function math.log(x: number): number !cimport('log') end
function math.fmod(x: number, y: number): number !cimport('fmod') end

-- used internally
local RAND_MAX: int32 !cimport
local function clog2(x: number): number !cimport('log2') end
local function clog10(x: number): number !cimport('log10') end
local function cmodf(x: number, y: number*): number !cimport('modf') end
local function crand(): int32 !cimport('rand') end
local function csrand(x: uint32) !cimport('srand') end

function math.atan2(x: number, y: number): number !cimport('atan2') end

local function math_logbase(x: number, base: number): number
  if base == 2 then
    return clog2(x)
  elseif base == 10 then
    return clog10(x)
  end
  return math.log(x) / math.log(base)
end

function math.deg(x: number)
  return x * (180.0 / math.pi)
end

function math.rad(x: number)
  return x * (math.pi / 180.0)
end

function math.modf(x: number)
  local i: number
  local f = cmodf(x, &i)
  return i, f
end

function math.random()
  local randmax = RAND_MAX
  local r: number = (crand() % randmax) / randmax
  return r
end
--TODO:randommax
--TODO:randomrange

function math.randomseed(x: number)
  csrand(@uint32(x))
end

function math.ult(m: integer, n: integer): boolean
  return @uinteger(m) < @uinteger(n)
end

function math.tointeger(x: number)
  return @integer(x)
end

--[[
local function type(x: number)
  return 'float'
end
assert(type(1.0) == 'float')
]]

--------------------------------
-- tests
local function assert_equal(x: number, y: number)
  assert(math.abs(x - y) < 1e-12)
end

local e: compconst = 2.718281828459045
assert_equal(math.abs(-1.0), 1)
assert_equal(math.abs(1.0), 1)
assert_equal(math.ceil(0.1), 1)
assert_equal(math.ceil(1.0), 1)
assert_equal(math.floor(0.9), 0)
assert_equal(math.floor(0.0), 0)

assert_equal(math.min(1.0, -1.0), -1)
assert_equal(math.min(-1.0, 1.0), -1)
assert_equal(math.max(1.0, -1.0), 1)
assert_equal(math.max(-1.0, 1.0), 1)
assert(math.min(math.huge, -math.huge) == -math.huge)
assert(math.max(math.huge, -math.huge) == math.huge)

assert_equal(math.acos(-1.0), math.pi)
assert_equal(math.acos(1.0), 0)
assert_equal(math.asin(0.0), 0)
assert_equal(math.asin(1.0), math.pi/2)
assert_equal(math.atan(0.0), 0)
assert_equal(math.atan(1.0), math.pi/4)
assert_equal(math.atan2(0.0, 1.0), 0)
assert_equal(math.atan2(0.0, -1.0), math.pi)

assert_equal(math.cos(math.pi), -1)
assert_equal(math.cos(0.0), 1)
assert_equal(math.sin(math.pi/2), 1)
assert_equal(math.sin(0.0), 0)
assert_equal(math.tan(math.pi/4), 1)
assert_equal(math.tan(0.0), 0)

assert_equal(math.deg(math.pi / 2), 90)
assert_equal(math.deg(0), 0)
assert_equal(math.rad(90), math.pi / 2)
assert_equal(math.rad(0), 0)

assert_equal(math.sqrt(4.0), 2)
assert_equal(math.sqrt(9.0), 3)
assert_equal(math.exp(0), 1)
assert_equal(math.exp(1), e)
assert_equal(math.log(1), 0)
assert_equal(math.log(e), 1)
assert_equal(math_logbase(1, 2), 0)
assert_equal(math_logbase(2, 2), 1)
assert_equal(math_logbase(1, 10), 0)
assert_equal(math_logbase(10, 10), 1)

assert_equal(math.fmod(5, 2), 1)
assert_equal(math.fmod(2.3, 5.7), 2.3)

local i: number, f: number
i, f = math.modf( 5.0)  assert_equal(i, 5)  assert_equal(f, 0.0)
i, f = math.modf( 5.3)  assert_equal(i, 5)  assert_equal(f, 0.3)
i, f = math.modf(-5.3)  assert_equal(i,-5)  assert_equal(f,-0.3)

assert(not (math.maxinteger < math.mininteger))
assert(math.ult(math.maxinteger, math.mininteger))
assert(math.tointeger(1.0) == 1_integer)

math.randomseed(0)
for i=1,10 do
  local x = math.random()
  assert(x >= 0 and x <= 1)
end
