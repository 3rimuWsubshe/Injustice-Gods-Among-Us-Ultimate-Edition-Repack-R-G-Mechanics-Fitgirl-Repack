-- SDL2 Snake Game Demo

-- import SDL headers
!!cdefine 'SDL_DISABLE_IMMINTRIN_H'
!!cinclude '<SDL2/SDL.h>'
!!linklib 'SDL2'

-- import SDL structures
local SDL_Event = @record {
  type: uint32,
  padding: array<byte, 56>
}
local SDL_Keysym = @record {
  scancode: cint,
  sym: int32,
  mod: uint16,
  unused: uint32
}
local SDL_KeyboardEvent = @record {
  type: uint32,
  timestamp: uint32,
  windowID: uint32,
  state: uint8,
  repeated: uint8,
  padding: uint16,
  keysym: SDL_Keysym
}
local SDL_Rect = @record {
  x: cint, y: cint,
  w: cint, h: cint,
};

-- import SDL pointers
local SDL_Window = @record{}*
local SDL_Renderer = @record{}*

-- import SDL constants
local SDL_INIT_VIDEO: uint32 !cimport
local SDL_WINDOWPOS_UNDEFINED: cint !cimport
local SDL_WINDOW_OPENGL: uint32 !cimport
local SDL_QUIT: uint32 !cimport
local SDL_KEYDOWN: uint32 !cimport
local SDLK_UP: int32 !cimport
local SDLK_DOWN: int32 !cimport
local SDLK_LEFT: int32 !cimport
local SDLK_RIGHT: int32 !cimport
local SDL_RENDERER_ACCELERATED: uint32 !cimport
local SDL_RENDERER_PRESENTVSYNC: uint32 !cimport

-- import SDL functions
local function SDL_Init(flags: uint32): int32 !cimport end
local function SDL_CreateWindow(title: cstring, x: cint, y: cint, w: cint, h: cint, flags: uint32): SDL_Window !cimport end
local function SDL_Quit() !cimport end
local function SDL_DestroyWindow(window: SDL_Window) !cimport end
local function SDL_Delay(ms: uint32) !cimport end
local function SDL_PollEvent(event: SDL_Event*): int32 !cimport end
local function SDL_WaitEvent(event: SDL_Event*): int32 !cimport end
local function SDL_CreateRenderer(window: SDL_Window, index: cint, flags: uint32): SDL_Renderer !cimport end
local function SDL_DestroyRenderer(renderer: SDL_Renderer) !cimport end
local function SDL_RenderPresent(renderer: SDL_Renderer) !cimport end
local function SDL_RenderClear(renderer: SDL_Renderer) !cimport end
local function SDL_SetRenderDrawColor(renderer: SDL_Renderer, r: uint8, g: uint8, b: uint8, a: uint8): cint !cimport end
local function SDL_RenderFillRect(renderer: SDL_Renderer, rect: SDL_Rect*): cint !cimport end
local function SDL_GetTicks(): uint32 !cimport end
local function rand(): int32 !cimport('rand') end

-- game types
local Point2D = @record{x: integer, y: integer}
local Direction = @enum<byte>{NONE=0, UP, DOWN, RIGHT, LEFT, UNSEEN}
local Color = @record{r: byte, g: byte, b: byte}

-- game constants
local const TILE_SIZE = 16
local const SCREEN_SIZE = 512
local const MAP_SIZE = 32 --SCREEN_SIZE / TILE_SIZE
local const MOVE_DELAY = 128
local const COLOR_PINK = Color{r=255, g=0, b=255}
local const COLOR_GREEN = Color{r=0, g=255, b=0}
local const COLOR_BLACK = Color{r=0, g=0, b=0}

-- game state variables
local renderer
local movedir = Direction.UP
local quit = false
local nextmove = 0
local headpos, tailpos, applepos
local tiles: Direction[MAP_SIZE][MAP_SIZE]

-- poll input events
local function poll_events()
  local event: SDL_Event
  while SDL_PollEvent(&event) do
    switch event.type
    case SDL_QUIT then
      quit = true
    case SDL_KEYDOWN then
      local kevent = @SDL_KeyboardEvent*(&event)
      switch kevent.keysym.sym
      case SDLK_UP then
        if movedir ~= Direction.DOWN then
          movedir = Direction.UP
        end
      case SDLK_DOWN then
        if movedir ~= Direction.UP then
          movedir = Direction.DOWN
        end
      case SDLK_RIGHT then
        if movedir ~= Direction.LEFT then
          movedir = Direction.RIGHT
        end
      case SDLK_LEFT then
        if movedir ~= Direction.RIGHT then
          movedir = Direction.LEFT
        end
      end
    end
  end
end

local function move_point(pos: Point2D, dir: Direction)
  switch dir
  case Direction.UP then
    pos.y = pos.y - 1
  case Direction.DOWN then
    pos.y = pos.y + 1
  case Direction.RIGHT then
    pos.x = pos.x + 1
  case Direction.LEFT then
    pos.x = pos.x - 1
  end
  return pos
end

local function set_tile(pos: Point2D, dir: Direction)
  tiles[pos.x][pos.y] = dir
end

local function reset_tile(pos: Point2D)
  tiles[pos.x][pos.y] = Direction.NONE
end

local function get_tile(pos: Point2D)
  return tiles[pos.x][pos.y]
end

local function has_tile(pos: Point2D)
  return tiles[pos.x][pos.y] ~= Direction.NONE
end

local function respawn_apple()
  -- respawn until there is no collision with its body
  repeat
    applepos = Point2D{
      x = rand() % MAP_SIZE,
      y = rand() % MAP_SIZE
    }
  until not has_tile(applepos)
end

local function init_game()
  tiles = {}
  headpos = Point2D{x=MAP_SIZE//2, y=MAP_SIZE//2}
  tailpos = Point2D{x=headpos.x,   y=headpos.y+1}
  movedir = Direction.UP
  set_tile(headpos, Direction.UP)
  set_tile(tailpos, Direction.UP)
  respawn_apple()
end

local function poll_game()
  local now = SDL_GetTicks()
  if now < nextmove then return end
  nextmove = now + MOVE_DELAY

  -- move the head
  set_tile(headpos, movedir)
  headpos = move_point(headpos, movedir)

  -- check collision with map boundaries
  if headpos.x >= MAP_SIZE or headpos.y >= MAP_SIZE or
     headpos.x < 0 or headpos.y < 0 then
    init_game() -- game over
    return
  end

  -- check collisions with its body
  if has_tile(headpos) then
    init_game()
    return
  end

  -- place head on next tile
  set_tile(headpos, Direction.UNSEEN)

  -- check collision with apple
  if headpos.x == applepos.x and headpos.y == applepos.y then
    respawn_apple()
  else
    -- eat tail
    local taildir = get_tile(tailpos)
    reset_tile(tailpos)
    tailpos = move_point(tailpos, taildir)
  end
end

local function draw_background(color: Color)
  SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, 255)
  SDL_RenderClear(renderer)
end

local function draw_tile(pos: Point2D, color: Color)
  SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, 255)
  SDL_RenderFillRect(renderer, &SDL_Rect{
    x = @int32(pos.x * TILE_SIZE),
    y = @int32(pos.y * TILE_SIZE),
    w = TILE_SIZE,
    h = TILE_SIZE
  })
end

local function draw_apple()
  draw_tile(applepos, COLOR_PINK)
end

local function draw_snake()
  for x=0,MAP_SIZE-1 do
    for y=0,MAP_SIZE-1 do
      local pos = Point2D{x=x,y=y}
      if has_tile(pos) then -- snake is present at this tile
        draw_tile(pos, COLOR_GREEN)
      end
    end
  end
end

local function draw()
  draw_background(COLOR_BLACK)
  draw_apple()
  draw_snake()
end

local function go()
  -- init sdl
  SDL_Init(SDL_INIT_VIDEO)

  local window = SDL_CreateWindow("An SDL2 Window",
    SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
    SCREEN_SIZE, SCREEN_SIZE, SDL_WINDOW_OPENGL)
  assert(window, "Could not create window")

  renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC)
  assert(renderer, "Could not create renderer")

  init_game()

  -- draw loop
  repeat
    poll_events()
    poll_game()
    draw()

    -- swap buffers
    SDL_RenderPresent(renderer)
  until quit

  -- cleanup and finish
  SDL_DestroyWindow(window)
  SDL_DestroyRenderer(renderer)
  SDL_Quit()
end

go()
